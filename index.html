
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Chouqin's Blog</title>
  <meta name="author" content="chouqin">

  
  <meta name="description" content="还是踩着年末的尾巴发一篇年终总结吧。 2013对我来说不是平淡的一年。
这一年，我大学毕业，从一所大学来到另外一所大学，
分别原来的同学和朋友，
又在新的地方建立起了人际关系网；
这一年，我从大学生变成了研究生，
伴随着学历的增长，我的生活节奏也完全发生变化，
现在的我，开始沉下心来学习一些东西 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://chouqin.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Chouqin's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  



<!-- mathjax config similar to math.stackexchange -->

	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	    tex2jax: {
	      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	      processEscapes: true
	    }
	  });
	</script>

	<script type="text/x-mathjax-config">
	    MathJax.Hub.Config({
	      tex2jax: {
		skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
	      }
	    });
	</script>

	<script type="text/x-mathjax-config">
	    MathJax.Hub.Queue(function() {
		var all = MathJax.Hub.getAllJax(), i;
		for(i=0; i < all.length; i += 1) {
		    all[i].SourceElement().parentNode.className += ' has-jax';
		}
	    });
	</script>

	<script type="text/javascript"
	   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Chouqin's Blog</a></h1>
  
    <h2>A blog for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:chouqin.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/about">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/31/2013-summary/">2013年终总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-31T21:56:00+08:00" pubdate data-updated="true">Dec 31<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>还是踩着年末的尾巴发一篇年终总结吧。</p>

<p>2013对我来说不是平淡的一年。
这一年，我大学毕业，从一所大学来到另外一所大学，
分别原来的同学和朋友，
又在新的地方建立起了人际关系网；
这一年，我从大学生变成了研究生，
伴随着学历的增长，我的生活节奏也完全发生变化，
现在的我，开始沉下心来学习一些东西，
虽然现在仍然没有很大的成果。
这一年，我和她吵了不知道多少次架，
每次都是因我而起，我心里十分愧疚，
我现在仍然不够成熟，
心胸不够开阔。</p>

<h2 id="section">计划的完成程度</h2>

<blockquote>
  <p>多看书，多感受生活，开阔自己的胸襟</p>
</blockquote>

<p>虽然这被放在了计划的第一条，但是完成的最不好。
这里的“看书”，当然是说非专业的书籍，
印象当中就看了《天龙八部》和《唐浩明评点曾国藩家书》（上下册），
家书下册还是这两天逼迫自己看完的，
看书之少，现在都替自己不好意思。</p>

<p>至于修身，也没有花多少功夫，
否则也不至于跟女朋友吵那么多架。
没有把这个放在比较重要的位置，
仍然还是我行我素，
只知道在专业方面努力，
其他方面都不在乎。
这一点，在来年必须要改。</p>

<blockquote>
  <p>学习一门新的编程语言，可能是go或者erlang</p>
</blockquote>

<p>也完成的不是很好，大概的学习了一下go(完成了go tour)，
没有用它写过实际的项目。</p>

<blockquote>
  <p>学完完有关数据挖掘的基础知识</p>
</blockquote>

<p>这个完成得还不错，
掌握了很多的机器学习和数据挖掘方面的基础知识。
完成了毕业设计，使用scikit-learn开发过机器学习程序，
写了很多实现机器学习算法的matlab代码。
上了两门机器学习的课程，一门是浙大蔡登老师上的，
另一门是Coursera上的。</p>

<blockquote>
  <p>为github上的一个库提交代码</p>
</blockquote>

<p>为<a href="https://github.com/easychen/TeamToy-Plugins">TeamToy-Plugin</a>这个项目写了两个插件，
一个是OpenId的，一个是创意墙（团队用户可以在上面分享创意，使用类似于Hacknews的排序，
这个插件没有提交）。</p>

<p>这个计划完成程度也不是很满意，投入的时间太少了。</p>

<h2 id="section-1">计划之外</h2>

<h3 id="section-2">专业书</h3>

<p>2013年在专业方面的投入还是蛮多的，
看过的书不能算少，也不能算多：</p>

<ol>
  <li>
    <p>《The C Programming Language》，这仅仅只有200多页的书，
除了让我知道如何写出好的C程序之外，
也让我明白了如何如何精简地表达自己的观点。</p>
  </li>
  <li>
    <p>《The CPP Programming Language》，以前一直对这本书持保留看法，
觉得这么厚的一本书一定晦涩难懂，
直到我认认真真地把整本书都看了一遍，
才发现这是一本不可多得的好书。
整本书讲解清晰，
把C++这么复杂的一门语言的语言特性阐释得十分清楚，
而且，里面还有很多如何写出更好的程序的技巧，
很多时候作者的很多思想会引起我强烈的共鸣，
或者启发我深度的思考。</p>
  </li>
  <li>
    <p>《Introduction to Data Mining》，
这本书总体感觉是介绍性质的，里面设计的理论不是很深，
数学讲解不是很多，不过能从中知道数据挖掘的各个方面。
可能Jiawei Han老师的那本数据挖掘更好一些。</p>
  </li>
  <li>
    <p>《Pattern Classification》，
这本书是上机器学习课程的主要教材，
里面的理论讲得很深，
是一本比较好的参考书。</p>
  </li>
  <li>
    <p>《The Practice of Programming》,
看这本书，完全是冲着Robert Pike的大名去的，
看完之后果然不失所望，
学到了很多的编程方法，
只是这本书的评注实在让人哭笑不得。</p>
  </li>
  <li>
    <p>《Effective Java》,
这本书看的是中文版，
翻译得不是很好，
有少数几个地方有点难以理解。
由于以前写的Java程序太少，
看完这本书之后收益还是蛮大的，
至少现在知道怎么去写Java程序了，
同时对于面向对象的特性也有了更加深入的理解。</p>
  </li>
</ol>

<p>应该说，今年看书确实比以往有所长进，
因为看完书之后能够对它进行总结，
其中一些重要的观点和思想都记录下来，
而不是看完就忘记了。
我觉得这是一种很好的看书方法，
看书不应该一味的追求速度，
看完之后的总结很有必要。</p>

<h3 id="coding">Coding</h3>

<p>2013年写过的代码不能算多，写的代码是PHP和Python，
但是有时候也看一些其它语言的书和文章，
然后拿着这些特性来进行一个比较，
想得比较多。同时，
有时需要写一些代码来测试一些有趣的语言特性，
这些代码可以作为以后的参考。</p>

<p>同时，今年看了几个开源项目的代码，
包括scrapy和redis，
看这些代码一方面能够开阔自己的视野，
另一方面对于如何写程序也能够有所体会。</p>

<h3 id="paper">Paper</h3>

<p>2013年也看过一些论文，
包括google的三大论文，
还有graphlab的4篇论文，
Spark的两篇论文。
对于后面的两种论文，
现在理解还不是很深入，
幸亏存在开源的代码能够加深理解。</p>

<p>在机器学习方面也看过一些论文，
其中推荐系统和聚类方面的论文看得比较多。</p>

<h2 id="section-3">2014年计划</h2>

<ol>
  <li>修身仍旧还是第一位，而且必须要花一定的时间。</li>
  <li>多看书，多看非专业书。</li>
  <li>看完Graphlab和Spark的源码, 期间需要巩固C++和学习Scala。</li>
  <li>上完Convex Optimization、Probabilistic Graphical Models
和Neural Networks for Machine Learning这三门在线课程。</li>
  <li>在github上为开源项目提交代码。</li>
</ol>

<p>祝愿所有人新年快乐，新的一年实现自己的梦想。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/24/bigtable/">Bigtable 学习心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-24T20:49:00+08:00" pubdate data-updated="true">Oct 24<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">基本介绍</h2>

<p>Bigtable是一个分布式的数据库，
它的出现主要是因为传统的关系型数据库在面对大量数据（PB级别）时不具有扩展性。
Bigtable在谷歌内部得到了广泛使用，
<a href="http://hbase.apache.org/">Apache HBase</a>是它的开源实现。</p>

<h3 id="section-1">数据格式</h3>

<p>可以把一个Bigtable当成一个持久化的，分布式的，多维的map。
它的值通过<code>(rowkey, columnkey, timestamp)</code>来索引。
其中<code>rowkey</code>，<code>columnkey</code>和值都可以是任意的字符串。
如下图所示。</p>

<p><img src="/images/row_column.jpg" alt="Bigtable数据示意图" /></p>

<p>在上图中，<code>rowkey</code>是<code>com.cnn.www</code>。
在Bigtable中，对row的操作是原子(atomic)的。
在Bigtable中，数据的保存顺序是通过<code>rowkey</code>的字典序来维持的，
基于这个特点，可以通过挑选合适的<code>rowkey</code>把相关的数据放在一起。
比如上图，通过使用倒序的主机名作为<code>rowkey</code>，
可以把同一域名下的网页放在一起。
几个row组合起来形成一个tablet，
一个table由一个或多个tablet组成。</p>

<p><code>columnkey</code>通过<code>column family</code>来进行划分，
如上图，anchor就是一个<code>column family</code>，它有两个<code>column key</code>：
<code>anchor:cnnsi.com</code>和<code>anchor:my.look.cn</code>。
contents也是一个<code>column family</code>, 它只有一个<code>column key</code>，
就是<code>contents:</code>。<code>column family</code>是访问控制的基本单位。
每一个<code>column key</code>必须以<code>column family:qualifier</code>的格式命名。</p>

<p>对于同一个<code>rowkey</code>和<code>columnkey</code>的组合，
Bigtable根据不同的<code>timestamp</code>保存了不同的值。
通常，会保存最近的几个版本（具体的版本数用户可以指定），
过期的数据会被垃圾回收掉。</p>

<h3 id="api">API</h3>

<p>Bigtable的API非常简单，下面是两个使用API的例子： </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>写Bigtable</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">// Open the table</span>
</span><span class="line"><span class="n">Table</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="n">OpenOrDie</span><span class="p">(</span><span class="s">&quot;/bigtable/web/webtable&quot;</span><span class="p">);</span>
</span><span class="line"><span class="c1">// Write a new anchor and delete an old anchor</span>
</span><span class="line"><span class="n">RowMutation</span> <span class="n">r1</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s">&quot;com.cnn.www&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">r1</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;anchor:www.c-span.org&quot;</span><span class="p">,</span> <span class="s">&quot;CNN&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">r1</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span><span class="s">&quot;anchor:www.abc.com&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">Operation</span> <span class="n">op</span><span class="p">;</span>
</span><span class="line"><span class="n">Apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的代码段对<code>rowkey="com.cnn.www"</code>的行，
将<code>columnkey="anchor:www.c-span.org"</code>的列的值设置为<code>CNN</code>，
同时删除<code>columnkey = "anchor:www.abc.com"</code>的列。其中<code>Apply()</code>是原子操作。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>读Bigtable</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="n">Scanner</span> <span class="n">scanner</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span><span class="line"><span class="n">ScanStream</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>
</span><span class="line"><span class="n">stream</span> <span class="o">=</span> <span class="n">scanner</span><span class="p">.</span><span class="n">FetchColumnFamily</span><span class="p">(</span><span class="s">&quot;anchor&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">stream</span><span class="o">-&gt;</span><span class="n">SetReturnAllVersions</span><span class="p">();</span>
</span><span class="line"><span class="n">scanner</span><span class="p">.</span><span class="n">Lookup</span><span class="p">(</span><span class="s">&quot;com.cnn.www&quot;</span><span class="p">);</span>
</span><span class="line"><span class="k">for</span> <span class="p">(;</span> <span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">Done</span><span class="p">();</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s %s %lld %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">            <span class="n">scanner</span><span class="p">.</span><span class="n">RowName</span><span class="p">(),</span>
</span><span class="line">            <span class="n">stream</span><span class="o">-&gt;</span><span class="n">ColumnName</span><span class="p">(),</span>
</span><span class="line">            <span class="n">stream</span><span class="o">-&gt;</span><span class="n">MicroTimestamp</span><span class="p">(),</span>
</span><span class="line">            <span class="n">stream</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">());</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的代码段遍历<code>rowkey="com.cnn.www"</code>的行中<code>column family="anchor"</code>的所有列的所有版本。</p>

<h2 id="section-2">实现</h2>

<p>Bigtable使用了几个部件构建而成：</p>

<ul>
  <li>GFS，Bigtable的底层依赖GFS，它使用GFS来保存数据和commit log，马上就会讲述细节。</li>
  <li>
    <p>Chubby，是Google发布的另外一个分布式系统，它具体的原理我还没有去看那篇论文，
  现在只需要知道Bigtable使用Chubby来完成下面的事情：</p>

    <ul>
      <li>保证任何时候只有一个bigtable master server</li>
      <li>存放Bigtable最开始的数据，用于定位METADATA，接下来会看到。</li>
      <li>用于监控tablet server的状态</li>
      <li>存放schema</li>
      <li>存放ACL(access control list)</li>
    </ul>

    <p>Chubby对于Bigtable非常重要，如果它停止工作了，
  那么整个Bigtable也停止工作。
  Chubby的开源实现是<a href="http://zookeeper.apache.org/">ZooKeeper</a>，
  下次再来研究Chubby。</p>
  </li>
</ul>

<h3 id="section-3">组成部分</h3>

<p>和GFS类似，Bigtable也由三个部分组成，分别是:</p>

<ul>
  <li>client：用于和应用程序交互</li>
  <li>一个master: 管理整个系统，要做的工作包括分配tablet，
负载均衡，垃圾回收，处理schema的变化。</li>
  <li>很多的tablet server：一个tablet server负责多个tablet，
client对于tablet的读写请求直接与tablet server进行交互。</li>
</ul>

<p>需要注意的是，与GFS不一样，
关于tablet的位置信息client不需要通过master就可以知道(接下来就会提到)，
所以大部分情况下client都不需要和master交互，
这样master上的压力更小了。</p>

<h3 id="tablet">Tablet的位置</h3>

<p>Bigtable使用一个三层的结构来存放tablet的位置，
如下图所示。(论文上说这个和B+树比较像，
我倒觉得用inode来类比更加好理解)</p>

<p><img src="/images/tablet_location_hierarchy.png" alt="" /></p>

<p>首先，一个Chubby File保存了root tablet的位置。
root tablet是一个特殊的METADATA table，
它保存了所有其他METADATA tablet的位置。
每一个METADATA又保存了user tablet的位置。
所以，顺着这个结构走下来，就能找到任意的tablet的位置。</p>

<p>关于这个“位置”，我是这样理解的，
它应该是一个具体的tablet server的名字，
client知道了哪个tablet server之后就向那个tablet server发出请求。
如果是这样的话，把tablet重新分配之后master需要去更新这些保存位置的tablet。</p>

<p>这里还有几个计算：</p>

<ul>
  <li>如果一行占的空间是1KB，一个tablet的空间是128MB，
那么这样一个三层的结构能够保存的tablet的数目为$2^{34}$，
这个很容易理解，128MB / 1KB = $2^{17}$，两级下来就是$2^{34}$。</li>
  <li>客户端会缓存住tablet的location，这样就不用每次都去读这个层级的结构。
如果客户端没有缓存，那么它读取一个tablet需要3次和tablet server的交互
（读root，METADATA，user tablet各一次)。如果缓存过期了，
最多需要6次和tablet server的交互（对于这个，我的理解是，如果客户端缓存了root tablet的location,
但是它过期了，那么它首先顺着这个结构下去，需要3次，然后发现不对，
又重新向Chubby得到root的位置，又再次顺着这个结构下去3次，
一共6次）。</li>
</ul>

<h3 id="tablet-1">Tablet的分配</h3>

<p>一个tablet一次只会被分配给一个tablet server，
master保存下面的信息：</p>

<ul>
  <li>哪些tablet server是正常工作的（alive）</li>
  <li>哪些tablet被分配给哪些tablet server</li>
  <li>哪些tablet没有被分配（这个只是暂时的，master会把这些tablet分配好，外面看不到这个状态？）</li>
</ul>

<p>当一个tablet server启动时，
它会去获取Chubby的某个特定目录下的一个文件（一个tablet server唯一的对应这个目录下的一个文件）的互斥锁。
master通过检查这个目录查看哪些tablet server是alive的。
tablet server如果丢失了这个互斥锁，那么它会尝试重新获取，
如果这个文件不存在了，tablet server永远都拿不到这个锁了，
那么它会自动停止。
如果tablet server不工作了，它会释放这个锁，
这样master就知道它没有工作了，把它上面的tablet分配给其他的tablet server。</p>

<p>master会频繁地和那些正常工作的tablet server进行通信来获取它们的状态，
如果tablet server告诉master它失去了锁或者无法和这个tablet server进行通信，
那么master会尝试获取这个tablet server对应的文件锁，
如果能够拿到这个锁，说明Chubby能正常工作，
而这个tablet server要么死掉了要么不能和Chubby交互，
那么master就删除这个tablet server对应的文件，
这样这个tablet server就没用了，
然后master把这个tablet server上的tablet分配给其他的tablet server。</p>

<p>在master启动时，它会执行下面的步骤：</p>

<ol>
  <li>首先，它会去Chubby上获取master锁，确保同一时间只有一个master工作</li>
  <li>然后，扫描Chubby上的目录（就是上面提到的目录，所有tablet server对应的文件都在这个目录下），
知道哪些tablet server是alive的</li>
  <li>然后，和每个alive的tablet server交互，知道哪些tablet已经被分配了</li>
  <li>最后，便利tablet位置的三层结构（Figure 4），知道一共有哪些tablet，
然后把这些tablet分配给tablet server。</li>
</ol>

<p>这里有一个问题是，如果METADATA的tablet没有被分配，
那么它就不能被读取，那么第4步就没法进行了。
这个问题可以这样解决，如果需要读取某个tablet时它还没有被分配，
那么先把它分配给某个tablet server，然后就可以继续接下来的步骤。</p>

<p>当下面的情况发生时，tablet的分配情况要进行调整：</p>

<ul>
  <li>tablet被创建或删除</li>
  <li>tablet被合并</li>
  <li>tablet被切分成两个tablet</li>
</ul>

<p>前面两种情况都是在master进行的，所以master直接进行调整就行，
而第三种过程是在某个tablet server上进行的，
master怎么知道的呢？
当tablet server对tablet进行切分时，
它首先在METADATA的tablet上记录下这个新的tablet，
然后通知master发生了改变。
如果这个通知丢失了，
那么当master去请求这个被切分的tablet时，
tablet server会发现这个tablet的METADATA table只是请求的METADATA的一部分，
就知道发生了切分，然后告诉master。</p>

<h3 id="tablet-2">Tablet的保存</h3>

<p>下面来看下一个tablet具体是如何保存的。</p>

<p><img src="/images/tablet_representation.png" alt="Tablet的表示" /></p>

<p>根据<a href="http://www.nosqlnotes.net/archives/122">这篇博客</a>，
要保存一个tablet，有这么几个部分：</p>

<ul>
  <li>主SSTable，就是持久化的不可变的哈系表，保存在GFS上</li>
  <li>memtable，在内存中记录最近的修改操作</li>
  <li>commit log，修改记录，分为compacted和uncompacted（待会会说明）</li>
  <li>次SSTable(为了区分两种SSTable，我用了“主”， “次”，不是重要性的区分)，
这种SSTable是memtable的持久化版本，次SSTable的存在是为了加快recovery的速度，
因为recovery需要从commit log恢复memtable，同时可以释放memtable的内存</li>
</ul>

<p>有了这几个部分，对tablet的操作也就变得容易了，
对于写操作，只需要记录把操作记录在commit log中，
同时写入memtable。对于读操作，
由于数据不仅仅保存在主SSTable上，
还需要结合memtable和次SSTable来进行。</p>

<h3 id="compactions">Compactions</h3>

<p>Compaction主要是为了解决上面过程中出现的问题，它分为3种：</p>

<ul>
  <li>minor compaction: 这个操作就是把memtable中的内容保存到SSTable,
释放memtable的内存，同时减小recovery时需要读取的commit log的数目，
已经被保存到次SSTable上的操作对应的commit称为compacted，
recovery时只需要从uncompacted的commit log中恢复就行了。 </li>
  <li>merge compaction: 
因为每次读取操作时都需要读取主SSTable和相关的次SSTable，
所以次SSTable的数量不能太多，因此，
master会把一些次SSTable组合成一个新的次SSTable。</li>
  <li>major compaction: 
master把次SSTable和memtable中的内容整合到SSTable里，
这样，就能回收掉修改的和删除的记录所占的空间。</li>
</ul>

<h2 id="section-4">优化</h2>

<h3 id="locality-groups">Locality groups</h3>

<p>client可以把一些列组放在一起形成一个locality group,
在每一个tablet里面，会为每一个locality group生成一个单独的SSTable,
使用locality group的好处是：</p>

<ul>
  <li>可以提高读的性能，比如把网页的contents放在一个locality group，
而metadata放在另外一个locality group，
这样读取metadata时就不需要读取网页的内容。</li>
  <li>可以对于不同的locality采取不同的调优参数。比如，
可以把有些locality group的SSTable放入内存。</li>
</ul>

<h3 id="cache">Cache</h3>

<p>为了提高读性能，tablet server采用了两种级别的cache:</p>

<ol>
  <li>Scan Cache，缓存从SSTable返回的key-value对</li>
  <li>Block Cache，缓存从GFS读回来的SSTable的block</li>
</ol>

<h3 id="bloom-filters">Bloom filters</h3>

<p>读操作需要结合SSTable和memtable，因此，
可以通过bloom filter来制定某些locality group的数据不可能存在于某些SSTable，
这样就可以减少需要读取的SSTable的数量。
Bloom filter一般保存在tablet server的内存中。</p>

<h3 id="commit-log">Commit log实现</h3>

<p>在Bigtable中，每一个tablet server只保存一个commit log, 
这个commit log保存了所有的tablet相关的log。这样做的好处是：</p>

<ul>
  <li>如果每个tablet一个commit log，就会导致同时有很多写请求发到GFS,
这样就会很多的磁盘seek。</li>
  <li>这样限制了group commit的作用，
因为只有同一个tablet的写操作才能被合并成一个到一个group commit。</li>
</ul>

<p>所有tablet的commit log组合成一个文件增加了恢复的复杂性，
因为这样不同的tablet可能被迁移到不同的tablet server，
这样所有相关的tablet server都需要读取这个commit log来获取tablet的信息，
这个commit log会被重复读多次。</p>

<p>解决这个问题的一个办法是在recovery时，
先把commit log使用<code>&lt;table, row name, log sequence number&gt;</code>作为key进行排序，
这样一个tablet的commit log就是连续的，可以通过一次seek，
然后连续读就可以得到。
这个排序的过程也可以通过把这个commit log分成几块，然后并发地进行排序来加快速度。</p>

<p>为了避免GFS集群中由于网络原因或者load情况带来性能上的波动，
通常使用两个线程来完成写commit log的操作，
每一个线程有自己的commit log文件，
同一时课只有一个线程在写，
如果一个线程写出现了性能上的问题，
就切换到另外一个线程（因为两个线程使用了不同的文件，
可能分布到不同的chunkserver）。同时，
使用序列号来消除重复的commit log。</p>

<h3 id="recovery">加快recovery</h3>

<p>如果master把tablet从一个tablet server移到另一个，
源tablet server可以进行一次minor compaction，
这样uncompacted的commit log就减少了很多，
因为这个过程中可能会有其他的写操作，
所以在upload这个tablet时，
可以再进行一次非常快的minor compaction，
这样就不要进行recovery了。</p>

<h3 id="section-5">不变性</h3>

<p>利用SSTable的不可变性带来了以下的方便：</p>

<ul>
  <li>缓存。</li>
  <li>memtable是唯一可变的数据结果，对它使用<a href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>来消除读写冲突。</li>
  <li>回收垃圾只需要回收SSTable就好了。</li>
  <li>在split时，child tablet可以使用parent tablet的SSTable。</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/21/migrate-to-octopress/">把博客迁到Octopress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-21T20:02:00+08:00" pubdate data-updated="true">Oct 21<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>折腾了一个下午，终于把博客迁到到了Octopress。
迁移的原因主要有两点：</p>

<ul>
  <li>
    <p>喜欢Octopress整体的风格，包括它的响应式设计，
还有特别好看的<code>solarized</code>的语法高亮。</p>
  </li>
  <li>
    <p>以前在<code>jekyll</code>上写博客，在<code>github</code>上面开了两个库，
原因在于Github Pages上不允许运行ruby脚本，
这样很多功能包括分页就都不能做了。为了完成分页的目的，
我在一个库里保存博客的源代码，使用<code>jekyll</code>来生成静态页面，
然后另一个库也就是<code>chouqin.github.io</code>就完全是静态页面，
把它发布到Github Pages上去。Octopress也是这样，
只不过它省去了我的麻烦，要发布到Github Pages，
只要一条<code>rake deploy</code>就够了，非常方便。</p>
  </li>
</ul>

<p>来说一下具体的迁移过程吧。</p>

<h2 id="section">基础博客搭建</h2>

<p>其实完全是照着Octopress的<a href="http://octopress.org/docs/setup/">官方文档</a>一步步安装过来的，
官方博客已经写得很清楚了。Ruby管理使用的是<a href="http://rvm.io">rvm</a>。</p>

<p>出现了一个问题是<code>rake</code>安装的是10.1.0的版本，跟Gemfile对应的不一致，
直接把Gemfile里的那行改为<code>gem 'rake', '~&gt; 10.1.0'</code>。</p>

<h2 id="section-1">修改配置</h2>

<p>首先是按照文档修改了一些<code>_conf.yml</code>配置:</p>

<ul>
  <li>把使用的markdown改为<code>kramdown</code></li>
  <li>启用<code>pygments</code>来进行语法高亮</li>
  <li>Aside Bar只显示最近的Post和Github。</li>
  <li>配置了<code>disqus_short_name</code>。</li>
</ul>

<p>具体的配置可以查看我的<a href="https://github.com/chouqin/chouqin.github.io/tree/source">github</a></p>

<h3 id="mathjax">使用MathJax</h3>

<p>由于使用的是<code>kramdown</code>，它的语法包含数学，为了在页面上展示数学公式，
在<code>source/_includes/head.html</code>上加入以下的内容：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="c">&lt;!-- mathjax config similar to math.stackexchange --&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-mathjax-config&quot;</span><span class="nt">&gt;</span>
</span><span class="line">  <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Config</span><span class="p">({</span>
</span><span class="line">    <span class="nx">tex2jax</span><span class="o">:</span> <span class="p">{</span>
</span><span class="line">      <span class="nx">inlineMath</span><span class="o">:</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;$&#39;</span><span class="p">,</span><span class="s1">&#39;$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;\\(&quot;</span><span class="p">,</span><span class="s2">&quot;\\)&quot;</span><span class="p">]</span> <span class="p">],</span>
</span><span class="line">      <span class="nx">processEscapes</span><span class="o">:</span> <span class="kc">true</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">});</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-mathjax-config&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Config</span><span class="p">({</span>
</span><span class="line">      <span class="nx">tex2jax</span><span class="o">:</span> <span class="p">{</span>
</span><span class="line">	<span class="nx">skipTags</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;script&#39;</span><span class="p">,</span> <span class="s1">&#39;noscript&#39;</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;code&#39;</span><span class="p">]</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-mathjax-config&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Queue</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">	<span class="kd">var</span> <span class="nx">all</span> <span class="o">=</span> <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">getAllJax</span><span class="p">(),</span> <span class="nx">i</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">all</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	    <span class="nx">all</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">SourceElement</span><span class="p">().</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">className</span> <span class="o">+=</span> <span class="s1">&#39; has-jax&#39;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span>
</span><span class="line">   <span class="na">src=</span><span class="s">&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span><span class="nt">&gt;</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">迁移原来的博文</h2>

<p>原来的博客是基于<code>jekyll</code>的，对于每一篇博客，修改这几个地方即可：</p>

<ul>
  <li>删除掉前面的<code>Included file 'JB/setup' not found in _includes directory</code>。</li>
  <li>在配置上加入<code>comments: true</code>。</li>
</ul>

<h2 id="section-3">发布到七牛</h2>

<p>因为生成的是静态页面，所以也可以发布到七牛来加速访问。
在部署之前，你需要先<a href="https://portal.qiniu.com/signup?code=3l94gjc9mqzwx">注册</a>成为七牛用户，
然后获取<a href="https://portal.qiniu.com/setting/key">AccessKey 和 SecretKey</a>。</p>

<p>然后安装七牛的<a href="http://docs.qiniu.com/tools/v6/qrsync.html">qrsync</a>。</p>

<p>在<code>octopress</code>目录下创建<code>qiniu.conf</code>，写入以下内容:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="json"><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="nt">&quot;access_key&quot;</span><span class="p">:</span> <span class="s2">&quot;Please apply your access key here&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;secret_key&quot;</span><span class="p">:</span> <span class="s2">&quot;Dont send your secret key to anyone&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;bucket&quot;</span><span class="p">:</span> <span class="s2">&quot;Bucket name on qiniu resource storage&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;sync_dir&quot;</span><span class="p">:</span> <span class="s2">&quot;_deploy&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;async_ops&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;debug_level&quot;</span><span class="p">:</span> <span class="mi">1</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后执行<code>qrsync qiniu.conf</code>，就能部署到七牛了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/16/mapreduce/">MapReduce学习心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-16T00:00:00+08:00" pubdate data-updated="true">Oct 16<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">简介</h2>

<p>对于计算机系的同学来说，MapReduce这个词应该并不陌生，
现在是所谓的“大数据时代”，“大数据”这个词被炒得非常热。
何为“大数据”？随着互联网的发展，现在的数据越来越多，
给原先的技术带来了两方面的挑战，一是<strong>存储</strong>，
如何存储这些PB级别的数据，
二是<strong>分析</strong>， 如何对这么大的数据进行分析，
从中提取出有用的信息。</p>

<p>MapReduce就是一个对大数据进行分析的框架。
使用MapReduce，用户只需要定义自己的<code>map</code>函数和<code>reduce</code>函数，
然后MapReduce就能把这些函数分配到不同的机器上去并行的执行，
MapReduce帮你解决好调度，容错，节点交互的问题。
这样，一个没有分布式系统编程经验的人也可以利用MapReduce把自己的程序放到几千台机器上去执行。</p>

<p><code>map</code>和<code>reduce</code>都是来自于函数式编程的概念，<code>map</code>函数接受一条条的纪录作为输入，
然后输出一个个<code>&lt;key, value&gt;</code>对，<code>reduce</code>函数接受<code>&lt;key, values&gt;</code>对，
（其中<code>values</code>是每一个<code>key</code>对应的所有的<code>value</code>)，通过对这些<code>values</code>进行一个“总结”，
得到一个<code>&lt;key, reduce_value&gt;</code>。</p>

<p>比如拿经典的<strong>WordCount</strong>例子来说，对于文本中的每一个单词<code>word</code>，
<code>map</code>都会生成一个<code>&lt;word, 1&gt;</code>对（注意如果一个文本中一个单词出现多次就生成多个这样的对）,
<code>reduce</code>函数就会收到<code>&lt;word, 1,...&gt;</code>这样的输入，它的工作就是把所有的<code>1</code>都加起来，
生成一个<code>&lt;word, sum&gt;</code>。</p>

<p>MapReduce函数基于键值对进行处理，看起来很简单，
那很多的分析任务不仅仅只是简单的Wordcount而已，能够使用这两个函数来实现吗？
幸运的是，很多的大规模数据分析任务都能通过MapReduce来表达，
这也是为什么MapReduce能够作为一个框架被提出的原因，
在最后一个部分中会给出一些更加复杂的使用MapReduce的例子。</p>

<h2 id="section-1">架构</h2>

<p>在大概了解了MapReduce之后，我们来看一下它到底是怎么实现的。
我们首先看一下一个MapReduce任务执行完需要经过那些流程，
然后再看一下在实现MapReduce的时候需要考虑的几个因素。</p>

<h3 id="section-2">基本流程</h3>

<p><img src="/images/map_reduce_execution.png" alt="" /></p>

<p>我们首先假定把一个任务分成M个<code>map</code>Task和R个<code>reduce</code>task，
如上图,
整个任务的执行过程如下：</p>

<ol>
  <li>
    <p>首先根据<code>map</code>的数量把原来的数据分成M个splits，每一个split对应一个<code>map</code>task。</p>
  </li>
  <li>
    <p>在集群的节点上启动<code>master</code>，M个<code>map</code>task和N个<code>reduce</code>task, 
<code>master</code>把split分配给相应的<code>map</code>task。需要注意的是，
一个集群的节点（又称作一个worker）上可能有多个<code>map</code>task,
也有可能<code>map</code>task和<code>reduce</code>task在同一个worker。</p>
  </li>
  <li>
    <p>每一个<code>map</code>task读取自己的split，根据用户定义的<code>map</code>函数生成<code>&lt;key value&gt;</code>对，
把结果保存在<strong>本地文件</strong>中，
根据<code>key</code>的不一样，结果被写入到R个不同的文件。
这些文件的位置会告知给<code>master</code>，然后<code>master</code>再告知给相应的<code>reduce</code>task。</p>
  </li>
  <li>
    <p>当一个<code>reduce</code>task被告知这些文件的位置时，它通过远程调用读取这些文件的内容，
当和这个<code>reduce</code>task相关的所有文件都被读到之后，它把这些内容按照<code>key</code>进行一个排序，
然后就能保证同一个<code>key</code>的所有<code>values</code>同时被传给<code>reduce</code>。</p>
  </li>
  <li>
    <p><code>reduce</code>task使用用户定义的<code>reduce</code>函数处理上述排序好的数据，
将最终的结果保存到一个<strong>Global File System</strong>（比如GFS），
这是为了保证数据的可靠性。</p>
  </li>
</ol>

<h3 id="section-3">文件的保存</h3>

<p>在上述的过程中，我们看到<code>map</code>task的结果被保存在本地，
而把<code>reduce</code>task的结果保存在具有可靠性保证的文件系统上。
这是因为<code>map</code>task产生的是中间结果，当这些结果被<code>reduce</code>之后，
就可以被扔掉，不需要备份，这样可以节约磁盘空间。
而<code>reduce</code>task产生的是最终结果，需要一定的可靠性保证。</p>

<h3 id="split">split的粒度</h3>

<p>在对一个任务进行划分时，需要考虑split的粒度：</p>

<ul>
  <li>
    <p>如果split太小，M就会很大，
<code>master</code>需要纪录的数据就会很多，
就会消耗很多<code>master</code>的内存。</p>
  </li>
  <li>
    <p>如果split太大，一方面调度不具有灵活性，
因为调度是以split为单位的，一个较大的task无法被分割放到其他空闲的worker上去执行。
另一方面无法利用<code>locality</code>进行调度，
因为<code>map</code>task的输入文件一般保存在分布式文件系统上，
<code>master</code>在调度时尽量把一个split分配到较近的节点上去执行，
如果split太大超过了一个文件block的大小，
这样可能两个block在不同的节点上，甚至跨了不同的机架，
这样无法利用<code>locality</code>了。</p>
  </li>
</ul>

<p>所以，在实际应用中，split的大小为一个block。</p>

<h3 id="section-4">容错</h3>

<p>由于MapReduce被分布到上千台机器上去执行，
错误是不可避免的。
MapReduc需要在节点发生故障时进行处理。</p>

<p>当一个节点发生故障，
在这个节点上的所有的<code>map</code>task都需要重新执行，
因为<code>map</code>task的结果是保存在节点本地的，
节点发生故障之后，这些结果就不可用了。
而成功执行的<code>reduce</code>task就不需要重新执行了，
因为它的结果是保存在分布式文件系统上，
可靠性是可以保证的。</p>

<h2 id="section-5">常见应用</h2>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h3 id="section-6">矩阵向量乘法</h3>

<p>假设有一个<script type="math/tex">m \times n</script>的矩阵M，
它和一个n维列向量v的乘积是一个m维的列向量x，有</p>

<script type="math/tex; mode=display">
x_i = \sum_{j=1}^{n} m_{ij}v_j
</script>

<p>可以根据j，把M按列分成k块，把v也对应分成k块，
每个M块和对应的v块被分给一个<code>map</code>task，
<code>map</code>task生成的结果为<script type="math/tex">(i, m_{ij}v_j)</script>对，
<code>reduce</code>task把每一个i对应的所有<script type="math/tex">m_{ij}v_j</script>加起来。</p>

<h3 id="section-7">关系代数运算</h3>

<p>关系数据库表的Join，Selection，Projection, Union, Intersection, 
Difference，Group And Aggregation等操作都可以使用MapReduce来实现。</p>

<p>值得一提的是，对于Join运算，比如链接关系R(a, b)和关系S(b, c)，
在生成以b为键的键值对时，需要指定来自于哪一个关系，
比如关系R生成的键值对的形式为<code>&lt;b, (R, a)&gt;</code>,
这样<code>reduce</code>时就可以根据这个信息进行组合。</p>

<h3 id="section-8">矩阵乘法</h3>

<p>假设有一个<script type="math/tex">m \times n</script>的矩阵M，
和一个<script type="math/tex">n \times p</script>的矩阵N，
它们的乘积是一个<script type="math/tex">m \times p</script>的矩阵P,
有:</p>

<script type="math/tex; mode=display">
p_{ik} = \sum_{j=1}^{n} m_{ij}n_{jk}
</script>

<p>矩阵M和矩阵N的乘法可以看成是关系M(I, J, V)和关系N(J, K, W)先进行一次Join，
再进行一次Group And Aggregation之后的结果，
因此可以直接通过两次MapReduce进行矩阵的乘法运算。</p>

<p>如果想要一次MapReduce就得到结果，可以在<code>map</code>时以(i, k)为键生成键值对，
同样的，需要指明来自于矩阵M还是矩阵N，因此，相应的键值对的格式分别为
<script type="math/tex">((i, k), (M, j, m_{ij}))</script>(对于矩阵M)，<script type="math/tex">((i, k), (N, j, n_{jk}))</script>(对于矩阵N)。
<code>reduce</code>时进行相应的组合。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/10/gfs/">GFS学习心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-10T00:00:00+08:00" pubdate data-updated="true">Oct 10<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>又好久没写博客了，这几个月来零零散散做了一些事情，
学到的东西很杂，一直都没有形成系统，也没有在某些方面有很深的体会。
有些东西刚刚深入进去看了一点（比如<a href="redis.io">redis</a>，看过一些代码，下次一定要写点心得出来），
还没来得及总结，就被一些其他的事情把时间挤走了。而现在，
时间相对来说比较空闲，可以认真研究一些技术，学得一些东西了。</p>

<p>这几天一直在看<a href="http://research.google.com/archive/gfs.html">The Google File System</a>这篇论文，
看得很慢，一天才能看几页，有些地方还要反反复复看几遍才能“理解”，
但也确实学得了不少东西，包括一些分布式系统设计的基本思想，
以及如何根据应用的具体场景来做设计决策。
诚然，对于一个这么大的系统，要想弄明白它的全部细节是比较困难的，
能够把它的整个过程捋顺就可以了。本文中，
我把我对这篇论文印象比较深的内容用我自己的理解讲出来，
希望能够给对GFS感兴趣的同学一点帮助。</p>

<h2 id="section">特殊的应用场景</h2>

<p>GFS作为一个分布式的文件系统，
除了要满足一般的文件系统的需求之外，
还根据一些特殊的应用场景（原文反复提到的<code>application workloads and technological environment</code>），
来完成整个系统的设计。</p>

<h3 id="section-1">分布式文件系统的要求</h3>

<p>一般的分布式文件系统需要满足以下四个要求：</p>

<ul>
  <li>Performance：高性能，较低的响应时间，较高的吞吐量</li>
  <li>Scalability: 易于扩展，可以简单地通过增加机器来增大容量</li>
  <li>Reliability: 可靠性，系统尽量不出错误</li>
  <li>Availability: 可用性，系统尽量保持可用</li>
</ul>

<p>（注：关于reliability和availability的区别，
请参考<a href="http://unfolding-mirror.blogspot.com/2009/06/reliability-vs-availability.html">这篇</a>）</p>

<h3 id="gfs">GFS基于的假设</h3>

<p>基于对实际应用场景的研究，GFS对它的使用场景做出了如下假设：</p>

<ol>
  <li>
    <p>GFS运行在成千上万台便宜的机器上，这意味着节点的故障会经常发生。
必须有一定的容错的机制来应对这些故障。</p>
  </li>
  <li>
    <p>系统要存储的文件通常都比较大，每个文件大约100MB或者更大，
GB级别的文件也很常见。必须能够有效地处理这样的大文件，
基于这样的大文件进行系统优化。</p>
  </li>
  <li>
    <p>workloads的读操作主要有两种：</p>

    <ul>
      <li>
        <p>大规模的流式读取，通常一次读取数百KB的数据,
 更常见的是一次读取1MB甚至更多的数据。
 来自同一个client的连续操作通常是读取同一个文件中连续的一个区域。</p>
      </li>
      <li>
        <p>小规模的随机读取，通常是在文件某个随机的位置读取
 几个KB数据。
 对于性能敏感的应用通常把一批随机读任务进行排序然后按照顺序批量读取，
 这样能够避免在通过一个文件来回移动位置。（后面我们将看到，
 这样能够减少获取metadata的次数，也就减少了和master的交互）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>workloads的写操作主要由大规模的，顺序的append操作构成。
一个文件一旦写好之后，就很少进行改动。因此随机的写操作是很少的，
所以GFS主要针对于append进行优化。</p>
  </li>
  <li>
    <p>系统必须有合理的机制来处理多个client并发写同一个文件的情况。
文件经常被用于生产者-消费者队列，需要高效地处理多个client的竞争。
正是基于这种特殊的应用场景，GFS实现了一个无锁并发append。</p>
  </li>
  <li>
    <p>利用高带宽比低延迟更加重要。基于这个假设，
可以把读写的任务分布到各个节点，
尽量保证每个节点的负载均衡，
尽管这样会造成一些请求的延迟。</p>
  </li>
</ol>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/10/10/gfs/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/20/markup-lang/">使用markdown和reStructuredText生成文档</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-04-20T00:00:00+08:00" pubdate data-updated="true">Apr 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">基本介绍</h3>
<p><a href="http://daringfireball.net/projects/markdown/">Markdown</a>和
<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>(下面简称rst)
是现在比较流行的<a href="http://en.wikipedia.org/wiki/Lightweight_markup_language">轻量级标注语言</a>，
这些语言拥有比较强大的表现力，可以通过简单的书写代码就可以写出包含代码，图片，数学公式等各种格式的文档。
这样，我们不用把心思花在各种格式的调节，而只需要专注于文档的内容就行了。
我们通过标记语言写成的文本文件能够被转化为html, tex, pdf，epub, word等各种格式，
我们只需要利用标记语言提供的语法把文本文件写好，相应的转换器会为你转换为特定的文档格式。
我的博客其实都是使用markdown一个特定版本<a href="http://kramdown.rubyforge.org/">kramdown</a>写的，
然后转换为html来发布。</p>

<p>学习这些标记语言其实很简单，远远比学习latex简单，把它提供的一些语法都写一遍，比如说怎么写标题，
怎么写列表，怎么插入代码，怎么插入数学符号等等。知道怎么写了之后，
就多练习，写得多了，熟悉之后就会发现，确实能够省去你控制格式的很多烦恼。</p>

<h3 id="pandoc">使用pandoc</h3>

<p>Markdown有很多超集，比如上面提到的kramdown，这些超集在markdown的基础之上有提供了一些功能，
比如说原生的markdown是不支持数学公式的，但kramdown支持，
它可以把你写在两个在源文件中的这样一段markdown代码:</p>

<div class="highlight"><pre><code class="tex"><span class="sb">$$</span><span class="nb"></span>
<span class="nb">O</span><span class="o">(</span><span class="nb">g</span><span class="o">(</span><span class="nb">n</span><span class="o">))</span><span class="nb"> </span><span class="o">=</span><span class="nb"> </span><span class="nv">\{</span><span class="nb">f</span><span class="o">(</span><span class="nb">n</span><span class="o">)</span><span class="nb">: </span><span class="nv">\exists</span><span class="nb"> c,n， </span><span class="nv">\forall</span><span class="nb"> n </span><span class="nv">\geq</span><span class="nb"> n_</span><span class="m">0</span><span class="nb">,  </span><span class="m">0</span><span class="nb"> </span><span class="nv">\leq</span><span class="nb"> f</span><span class="o">(</span><span class="nb">n</span><span class="o">)</span><span class="nb"> </span><span class="nv">\leq</span><span class="nb"> cg</span><span class="o">(</span><span class="nb">n</span><span class="o">)</span><span class="nv">\}</span><span class="nb"></span>
<span class="s">$$</span>
</code></pre></div>

<p>转化为这样一段html:</p>

<div class="highlight"><pre><code class="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;math/tex; mode=display&quot;</span><span class="nt">&gt;</span>
    <span class="nx">O</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="o">=</span> <span class="err">\</span><span class="p">{</span><span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="o">:</span> <span class="err">\</span><span class="nx">exists</span> <span class="nx">c</span><span class="p">,</span><span class="nx">n</span><span class="err">，</span> <span class="err">\</span><span class="nx">forall</span> <span class="nx">n</span> <span class="err">\</span><span class="nx">geq</span> <span class="nx">n_0</span><span class="p">,</span>  <span class="mi">0</span> <span class="err">\</span><span class="nx">leq</span> <span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="err">\</span><span class="nx">leq</span> <span class="nx">cg</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="err">\</span><span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>

<p>包含这个的html<strong>如果里面包含<a href="http://www.mathjax.org/">MathJax</a>这个js库</strong>的话，
MathJax就会把上述的一段html转换为如下的数学公式呈现给你。</p>

<script type="math/tex; mode=display">
O(g(n)) = \{f(n): \exists c,n， \forall n \geq n_0,  0 \leq f(n) \leq cg(n)\}
</script>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/04/20/markup-lang/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/04/bachelor-thesis/">毕业论文点滴</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-04-04T00:00:00+08:00" pubdate data-updated="true">Apr 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>已经好久没写博客了，因为寒假一个多月都没看书，
而一回到学校，又要忙着毕业论文的事，所以也无暇顾及这个。
大部分牛人的博客，都是记载着自己正在研究的方面，
在博客中也是向读者传达着一些知识，我们总是可以从其中学到某种东西。
而我，要达到这样的程度要有很长的一段路需要走，
由于技术水平较低，现在的博客记录的仍然还是自己在<strong>学习</strong>过程中的一些心得和体会，
很大程度上是描述自己的坎坷经历，希望能给某些人一些借鉴，少走一些弯路。</p>

<p>好了，言归正传，这一个月，都在忙着做毕业设计，
包括看论文，写代码，找数据，做实验。一个月的时间，
就完成了这么一件事，效率确实不算高，
主要原因在于对于搞科研还是新手，
很多情况下都是在尝试了各种可能之后才找到方法，
有时一个人的蛮干还不如直接通过其他方式获得出路。
哎，科研就是要耐得住寂寞，不停地调参数，不停地跑数据，
把各种可能性都尝试一遍，之后才有好的结果。</p>

<p>先简单介绍一下我这个论文的要求，论文的题目叫
<code>信息缺失情况下的社区挖掘</code>，其实就是一个聚类算法，
根据节点的某些属性和节点之间的边的关系，把图中的比较接近的节点聚到一起，
形成一个社区。而信息缺失，是指节点中的某些边的关系并不知道，
在这样的情况下进行聚类。采用的办法是首先利用节点之间的属性和边的关系，
通过机器学习方法获取所有节点之间的距离，然后再根据这个距离对节点进行聚类。
下面我来说一下整个的过程。</p>

<p>首先是准备数据。一开始准备爬微博的数据，
所以就去网上搜各种微博的爬虫，
然后终于找到了这个<a href="https://bitbucket.org/chineking/weibocrawler">一个简单的分布式新浪微博爬虫</a>，
在这个基础上进行了一点小修改，弄了一个简单的单节点爬虫。
这个爬虫可以抓取用户的微博，用户的个人资料以及用户之间的关注关系。
然后，又使用<a href="http://ictclas.nlpir.org/">NLPIR</a>对微博进行分词，
提取出关键字作为用户的属性，同时以用户之间的关注关系作为边，这样就开始实验。
可是，不知道是实验室的网络不稳定还是新浪微博的限制，这个爬虫很难稳定地抓取微博的数据，
最后实在没办法，学长建议我去网上直接找别人爬取到的数据集。
于是，我先后使用了Google+, Facebook, 
Twitter(这三个数据集都是在<a href="http://snap.stanford.edu/data/">Stanford Large Network Dataset Collection</a>上找到的),
和Flixter数据集做实验。其中使用Flixter数据集做出来的结果也还可以，可是师兄说一定要有<strong>Ground Truth</strong>用于验证，
所以我又只好去找其他的数据集，
最后终于<a href="http://dmml.asu.edu/users/xufei/datasets.html">在这</a>找到了可以用于实验的数据集。</p>

<p>然后是实现代码去做实验。这个代码其实两部分，第一部分要利用机器学习去学习一个距离，
第二部分是基于距离进行聚类。为了学习距离，需要求解一个最优化函数，
而这里面涉及的数学的公式好复杂，实现起来也非常困难，
找到了一份和这个论文比较相似的论文的源代码，却发现里面错误好多，有些地方也不知道从哪里开始改。
大概修改了一下就把这个距离拿到第二步去聚类，发现结果非常差，
然后也不知道是第一步的问题还是第二步的问题，但是我就只会改第二步的代码:P。
终于在第二步实在找不出什么错误然后第一步的结果又不好之后，我去问老师，
老师让我使用谱聚类算法来验证距离是不是正确的，
因为谱聚类算法也是基于距离的聚类算法，如果谱聚类算法得不到正确的结果，那就是距离的问题了。
多好的主意啊，我当时怎么就没想到呢，因为我当时还没听说过谱聚类算法。
于是我就拿谱聚类算法去验证，果然是距离没学对，而除了代码没写对之外，
有一个重要的步骤没有做，<strong>对Feature做Normalize</strong>，
这个步骤对于使用节点的属性来说非常重要，它保证了所有属性的作用是均等的。
而后，我又在<a href="http://www.cs.cmu.edu/~liuy/distlearn.htm">这里</a>找到了一些其他的学习距离的算法，
我使用了其中的DCA算法来作为我的第一步，相当靠谱。
通过谱聚类算法验证之后，我发现我的第二步算法就几乎没有什么问题了，
跑出的结果也比较让人满意。</p>

<p>大概就是这么一个比较纠结的过程，总结出一些经验吧:</p>

<pre><code>&gt;&gt;&gt;import this
</code></pre>

<ol>
  <li>
    <p>写代码还是要多检查，一个bug除了导致几个小时的结果无效，还要浪费更多的时间去找到它。</p>
  </li>
  <li>
    <p>在一个步骤保证正确之前，不要急于开展下一步，这样只会增加更多的复杂性。</p>
  </li>
  <li>
    <p>沉下心来研究论文，尽量采用和别人一样的方法，得到的结果总是好些，虽然不知道为什么好。</p>
  </li>
  <li>
    <p>不要畏惧实验和失败，说不定下一次就是成功的那一次。</p>
  </li>
  <li>
    <p>真爱生命，远离科研。</p>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/06/clrs-24-26/">最短路径与最大流</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-06T00:00:00+08:00" pubdate data-updated="true">Jan 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">最短路径</h2>

<p>在最短路径问题中，
希望在一个图中找出从一个节点到另外一个节点的最短路径，
可能要找出从某一个特定节点到其他节点的最短路径，
也可能是找出所有节点对之间的最短路径，
图中边的权重可能为负值，甚至包含负的回路，
因此，在不同的情况下，有不同的算法适合求解问题，
关于求解所有节点之间的最短路径问题已经在动态规划时详细地解释过Floyd算法，
现在就谈谈两个处理单源最短路径的算法, Dijkstra算法和Bellman-Ford算法。</p>

<h3 id="dijkstra">Dijkstra算法</h3>

<p>Dijkstra算法用于求解所有边的权重为非负值时的单源最短路径问题，
它与Prim算法很相似，利用一个集合S保存已经求出最短路径的节点集合，
开始是S只包含源节点s,
每次从V-S中挑选出一个距离S中节点最近的节点u放入S，同时正确地设置u的邻居节点的路径长度，
直到S为V。</p>

<p>对于Dijkstra算法的正确性，只需要递归地证明下面的性质成立：</p>

<pre><code>当节点u被加入到S时，u到s的最短路径已经被正确的设置, 而且u到s的最短路径上的前趋节点w已经被添加进S。
</code></pre>

<ul>
  <li>初始化：一开始时，这个性质显然成立</li>
  <li>保持：假设当u被添加到S时，u到s的最短路径已经被正确的设置，对于u的任何一个邻接节点v，
如果s到v的最短路径是<script type="math/tex"> s \xrightarrow{p} u \xrightarrow{} v </script>，那么s到v的路径能够被正确的设置，
而且从v到s最短路径上的前趋节点u已经被添加进S, 这样当v被添加进S时，上述的性质都是能够保持的。</li>
</ul>

<h3 id="bellman-ford">Bellman-Ford算法</h3>

<p>Bellman-Ford算法用于求解权重可以为负值时的单源最短路径问题，
而且它还可以用于判断图中是否存在s可达的负的回路。
Bellman-Ford的执行过程就是运行|V|-1次更新操作，
每次更新操作遍历每一条边(u, v)更新dist[v]，伪代码如下：</p>

<div class="highlight"><pre><code class="pascal">    <span class="k">procedure</span> <span class="nf">update</span><span class="p">((</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">))</span><span class="o">:</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">,</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="mi">1</span> <span class="k">to</span> <span class="err">|</span><span class="n">V</span><span class="err">|</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">E</span><span class="o">:</span>
            <span class="n">update</span><span class="p">((</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">))</span>
</code></pre></div>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/01/06/clrs-24-26/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/01/new-2013/">再见2012，你好2013</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-01T00:00:00+08:00" pubdate data-updated="true">Jan 1<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>看着网络上各路牛人的年末总结，也想跟风自己来写一个，
只可惜拖的时间有点长，到现在才开始发表。</p>

<p>2012年对我来说绝对是不一样的一年，求职，面试，外推，实习，
以前对我来说很遥远的事情在这一年真真切切的发生。
有成功，也有失败，有欢笑，也有泪水，有面临抉择时的犹豫不决，
也有选择之后的淡定从容。这些经历，大多是艰辛的，
却没有将我击垮，能让自己觉得人生的充实。世界末日都照样过了，
还有什么挺不过呢？</p>

<p>在学习方面，2012年学习了很多新技术，新的语言，
对于算法，也有了更深入的理解。总的来说，还是广度有余，深度不足。
多多接触一些新的东西当然是有必要的，无论是对于开阔视野还是为了选择一个自己感兴趣的方向，
可是一个人必须要有所专长，在一个方面成为专家，这样才能体现个人的价值，
我在这方面仍然有所欠缺，希望在未来几年能够再某一个方面深入研究下去。
为什么是几年，因为我觉得有所建树，必须经过几年的积累。</p>

<p>在其他方面，相对来说就做得太少了一点，生活显得略微单调了一些。
空闲时间除了打打球，打打dota，似乎就没有干过别的什么事。更让我觉得愧疚的事，
很少看专业方面的其他书，思考的方式也越来越朝着计算机那个非0即1的方向去转了。
现在的情商好像是在下降，在2013年中一定要强迫自己多读书，多读与专业无关的书籍。</p>

<p>今年最好用的工具还是微博，在这上面可以很好地打发时间，
同时可以获取很多很有意思的信息。虽然说能学到的东西很少，
但它确实能很大程度地开阔视野，你能了解到很多你在现实生活中很难碰到的一些人和事。
喜欢微博，喜欢它带给我的快节奏信息。</p>

<p>今年最深的几点感触：</p>

<ol>
  <li>在面临选择时，不要过分地去权衡利弊，在做出选择之后坚定地超前走才是最重要的。</li>
  <li>不要固执地去争论一个观点的正确性，这并不是一个非黑即白的世界</li>
  <li>严于律己，宽以待人</li>
  <li>多看书，多思考，思考和学习一个都不能落下</li>
  <li>珍惜别人给自己的每一条建议</li>
</ol>

<p>2013 To-Do-List:</p>

<ol>
  <li>多看书，多感受生活，开阔自己的胸襟</li>
  <li>学习一门新的编程语言，可能是go或者erlang</li>
  <li>学完完有关数据挖掘的基础知识</li>
  <li>为github上的一个库提交代码</li>
</ol>

<p>祝愿我的亲人和朋友身体健康，考研的同学考上好的学校，
工作的同学工作顺心。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/30/clrs-22-23/">图的基本算法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-30T00:00:00+08:00" pubdate data-updated="true">Dec 30<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">广度优先遍历</h2>

<p>对于广度优先遍历，在每次遍历时，都试图把同一个级别的所有节点先遍历，
再遍历下一个级别的节点。它的实现方式是通过一个队列保存需要去遍历的节点，
在每次遍历到一个节点时，都把它的邻接节点放入队列（如果这个节点没有被遍历过的话）等待着被遍历，
这样能保证更深层次的节点会遍历在它的任何邻接节点的后面，因为它的邻接节点更先进入队列。</p>

<p>广度优先遍历可以用来求解无权图中的单源最短路径问题，
对于节点s，在它上面执行一次广度优先遍历就能求出各个节点和s相距的节点数，
这也就是它们到达节点s所需的距离。对于广度优先遍历，
算法首先会发现和s距离为k的所有节点，然后再去发现和s距离为k+1的节点。
这其实和Dijkstra算法是采用同样的思想，先找出和s距离更近的节点，
在这基础上再找出更远的节点，因为这样的话当确定好了更远节点的路径时，
就不需要反过来再去修改更近节点的路径，因为通过更远节点的路径肯定没有先前的那条路径好。</p>

<h2 id="section-1">深度优先遍历</h2>

<p>深度优先遍历与广度优先遍历不一样，在遍历到每一个节点时，尽量往更深节点去遍历，
遍历完之后再考虑同一个级别的节点。它的实现方式不需要队列，
直接通过递归函数就可以完成这个步骤。每次遍历到一个节点时，先把当前的节点设为已经遍历过，
然后在它的邻接节点上执行递归遍历的函数（没有遍历过的邻接节点）。如果对整个图进行深度优先遍历，
首先会选定一个节点，然后在它上面执行深度优先遍历，如果遍历到了所有节点就停止，
否则选择另一个没有遍历到的节点重复这个过程直至所有的节点都遍历完。在深度优先搜索的过程中，
会形成一棵棵以挑选出的节点为根的深度优先树组成的深度优先搜索森林。</p>

<p>在深度优先遍历遍历到每一个节点时，可以利用一个计数器记录遍历节点开始时的时间和结束时的时间，
依据这个时间来确定节点遍历的相对顺序。设节点v遍历的开始时间为d[v]，结束时间为f[v]，
那么时间区间[d[v], f[v]]就代表了这个节点处在遍历过程中的时间，更具体的说，
是节点处在递归函数的栈中的时间。因此对于任何节点u, v，
[d[v], f[v]]和[d[u]， f[u]]只能是不相交或者是一个包含另一个。
（通过栈可能更好理解一点）</p>

<p>利用这样的计数器，可以完成对图的很多操作，比如说拓扑排序和有向图的连通性检查。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/12/30/clrs-22-23/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/12/31/2013-summary/">2013年终总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/24/bigtable/">Bigtable 学习心得</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/21/migrate-to-octopress/">把博客迁到Octopress</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/16/mapreduce/">MapReduce学习心得</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/10/gfs/">GFS学习心得</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/chouqin">@chouqin</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'chouqin',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - chouqin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'chouqinblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
