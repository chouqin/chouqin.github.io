
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Chouqin's Blog</title>
  <meta name="author" content="chouqin">

  
  <meta name="description" content="2014年算是过得比较充实的一年，看了比较多的书和论文，
也沉下心来写过一些代码，在专业方面还是有不少的积累。
另外，在性格方面，也慢慢改变了一些自己的缺点，
虽然还需要继续努力～。 计划的完成程度 修身仍旧还是第一位，而且必须要花一定的时间。 这个感觉完成得并不是很好，不过需要慢慢来，
多反省， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://chouqin.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Chouqin's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  



<!-- mathjax config similar to math.stackexchange -->

	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	    tex2jax: {
	      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	      processEscapes: true
	    }
	  });
	</script>

	<script type="text/x-mathjax-config">
	    MathJax.Hub.Config({
	      tex2jax: {
		skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
	      }
	    });
	</script>

	<script type="text/x-mathjax-config">
	    MathJax.Hub.Queue(function() {
		var all = MathJax.Hub.getAllJax(), i;
		for(i=0; i < all.length; i += 1) {
		    all[i].SourceElement().parentNode.className += ' has-jax';
		}
	    });
	</script>

	<script type="text/javascript"
	   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Chouqin's Blog</a></h1>
  
    <h2>A blog for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:chouqin.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/about">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/31/2014-summary/">2014年终总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-31T18:13:00+08:00" pubdate data-updated="true">Dec 31<span>st</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>2014年算是过得比较充实的一年，看了比较多的书和论文，
也沉下心来写过一些代码，在专业方面还是有不少的积累。
另外，在性格方面，也慢慢改变了一些自己的缺点，
虽然还需要继续努力～。</p>

<h2 id="section">计划的完成程度</h2>

<blockquote>
  <p>修身仍旧还是第一位，而且必须要花一定的时间。</p>
</blockquote>

<p>这个感觉完成得并不是很好，不过需要慢慢来，
多反省，多总结就好。</p>

<blockquote>
  <p>多看书，多看非专业书。</p>
</blockquote>

<p>看的书还挺多的，待会再慢慢总结。</p>

<blockquote>
  <p>看完Graphlab和Spark的源码, 期间需要巩固C++和学习Scala。</p>
</blockquote>

<p>Spark的源码看了大部分，了解代码的基本结构，
知道每一个功能的实现大概在什么位置。一直在跟进社区的Pull Request，
在研究Spark上面花了不少的时间，坚持下来有不少的收获。这一点明年继续保持。
Scala也在读Spark源码过程中不断熟悉，现在看Spark的源码不会有不理解的地方了。</p>

<p>至于Graphlab，完全没看。。</p>

<blockquote>
  <p>上完Convex Optimization、Probabilistic Graphical Models
和Neural Networks for Machine Learning这三门在线课程。</p>
</blockquote>

<p>Convex Optimization比较圆满的完成了，看完了整本书，
同时顺便看了ADMM的那篇比较长的论文，Boyd老师真是大师，
讲课非常幽默，听完他的课之后对于优化这方面算是有了一个整体的框架，
了解了解决优化问题的思考方式。</p>

<p>另外两门课程没有参加，不过已经放在2015年的目标里了。</p>

<blockquote>
  <p>在github上为开源项目提交代码。</p>
</blockquote>

<p>今年给Spark提交过几个patch，主要是和MLlib里面的决策树相关。</p>

<p>整体来说，2014年的计划完成了60%吧，由于完成了计划之外的一些事情。</p>

<h2 id="section-1">看完的书</h2>

<h3 id="section-2">计算机方面的</h3>

<ol>
  <li>《Effective C++》: 想写好C++程序的必读书籍，
看完里面的建议能够避免一些初学者易犯的错误。
读起来并不难，关键需要在实际写代码的过程中去使用这些建议。</li>
  <li>《Unix编程艺术》：整本书的中心思想就两个字：简单。
通过简单的方式去实现程序，将程序拆分成简单的低耦合的模块。
这是一本关于“知识”，更关注于“思想”； 关于“方法”，更关注于“理念”的书。 整本书都是在讲述在UNIX哲学中如何设计软件， 如何使用工具，如何看待各种技术， 这是一本教你如何从UNIX的视角去看待问题的书。
且不说这里面的观点正确与否， 它确实能够给你提供一个看待问题的新的思路。 而且UNIX文化和哲学中拥有许多值得去领悟的精华。 看这本书一点都不觉得沉闷，每一个观点都能够引发我思考， 结合自己的经历得出新的感悟和体会。 书中的代码虽然不多，却能够教你如何编程， 而大量的软件实例分析又像一个个路标， 指出设计中的陷阱和正确的方向。</li>
  <li>《统计学习方法》：虽然只有一些简单的机器学习算法，
但是里面的公式推导还是比较好理解的。对于入门来说，这样一本中文的图书真的很有帮助。</li>
  <li>《多处理器编程的艺术》：这本书开阔了我对于写并发程序的看法，通过一个个并发数据结构的例子，
可以学习到编写“无锁”程序的技巧。为了写好并发的程序，需要对于底层的体系结构有一定的了解。
书中第3章有一些理论部分没有认真地看过。</li>
  <li>《计算机程序的构造和解释》：非常经典的一本书，
通过这本书可以体会到函数式编程的优雅。</li>
  <li>《编程人生》：英文名叫《Coders at Worker》，对于国外10多个优秀程序员的采访，
从这些人身上可以学习到程序设计的技巧和思考问题的方式。</li>
  <li>《Convex Optimization》：虽然整本书超过700页，但是理解起来并不困难，只要掌握微积分和线性代数即可。
看完整本书，结合对应的课程讲解，有一种豁然开朗的感觉。</li>
  <li>《Masterminds of Programming》: 采访了一些语言的作者，看完了对于C#的作者和Haskell作者的采访，
感觉一门语言能够支持EDSL很重要。</li>
  <li>《人月神话》：本书描述的是作者在上个实际60年代管理大型软件工程项目的一些经验和看法，
这些观点拿到现在来看也仍然没有过时。</li>
</ol>

<h3 id="section-3">非计算机的</h3>

<ol>
  <li>《史玉柱》：一本史玉柱自述的关于营销的书，观点都很实在，很接地气。</li>
  <li>《信息简史》：这本书和计算机也有一定的关系，讲述信息相关的各个方面，
介绍信息技术发展从古到今的一些科技成果，令人大开眼界。</li>
  <li>《The Elements of Style》: 讲述如何用英语进行写作的书，非常薄的一本书（才100多页），
对于如何使用词语、标点符号和如何组织段落等都有一些很好的建议。</li>
  <li>《自控力》：标题像鸡汤，其实是关于如何认识大脑中的三种不同的力量，
以及如何使用它们来达到自控的效果。书中的一些案例让我感同身受，
照着书中的建议去做确实能起到不错的效果。</li>
  <li>《周鸿祎》：看过的最差的书之一，里面提到的有用的观点很少，
大部分是对于360的自我标榜，重复的废话太多，根本不值得用一本书来讲述。</li>
  <li>《文明之光》：有点科技史的感觉，没有《浪潮之巅》和《数学之美》有趣，
不知道是不是个人兴趣的问题。</li>
  <li>《失控》：看完了前面3章，讲述如何真正地实现机器的智能，
使用群体的智慧。</li>
</ol>

<h2 id="section-4">计划之外</h2>

<h3 id="llvm">LLVM</h3>

<p>今年选了一门外教上的高级编译技术的课程。
课程主要完成对LLVM进行扩展，让它能够支持使用并行机器指令完成长整数的运算。
在整个过程中，我看完了LLVM官网上的所有文档，整个代码也看了很多，
后端从LLVM IR到最终生成机器码的整个过程算是了解得比较清楚。
最终大致得完成了整个项目，还发现了LLVM里面的一些bug。
LLVM的代码写得还不错，是我看过的写得最好的C++代码之一。
唯一不足的是除了官方的文档，其他人写得关于LLVM的文章很少，
不管是关于实现还是使用的。学这门课最主要的还是锻炼了我的英语口语:D。</p>

<h3 id="haskell">Haskell的课程</h3>

<p>今年在Edx上学习了一门FP101的课程，比较基础地学习了Haskell，
Haskell确实和我见过的程序设计语言不一样，它主张使用各种抽象来达到代码的复用。
其中，最难以理解的就是Monad这个概念，当时花了很长时间才明白Monad是什么，
而后通过Monad实现CPS让我不住惊叹于它的强大。现在，仍然不敢说已经完全理解Monad，
以后还需要多多使用来加深对它的理解。它能够给你一个全新的写程序的角度。另外，
Haskell的类型系统真的很强大，当时在没有完全理解CPS的情况下可以依靠类型系统的提示写出正确的程序。</p>

<h3 id="section-5">一些论文</h3>

<p>今年看了不少的论文（相对于以前来说），主要是和机器学习相关的，
看完这些论文除了让我对论文中描述的技术有更深入的理解之外，
更重要的是让我学会了一些看论文的方法，以及不再害怕阅读论文的能力。</p>

<h3 id="section-6">学车</h3>

<p>虽然2014年最后一天的科目三没有通过，稍稍有点遗憾，
但是整个学车的过程还是让我成长了很多。
我克服了自己内心的恐惧，勇敢地走出自己的舒适区，
在一个自己非常不擅长的领域努力并取得了一定的成功。
学车整个的过程确实让我的内心变得更加强大，我也不断地弥补了一些自己性格上的弱势。
现在离最终拿到驾照还有很长的一段路要走，但是我相信我一定会成功的。</p>

<h2 id="section-7">2015年计划</h2>

<ol>
  <li>拿到驾照，顺便锻炼自己强大的内心。</li>
  <li>学习go，深入了解Docker及相关的技术。</li>
  <li>机器学习方面，看完ESL和PRML（或者MLAPP)，学习落下的课程。</li>
  <li>多看书，多看和专业无关的书。</li>
  <li>跟进Spark的进展，争取在这方面能够有所建树。</li>
  <li>看完parameter_server或者petuum的源码。</li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/15/the-mythical-man-month/">《人月神话》读书心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-15T15:32:00+08:00" pubdate data-updated="true">Dec 15<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>花几天的时间读完了《人月神话》这本软件工程领域的经典书籍。
本书并不厚，作者的文笔很好，讲述一个观点时能够解释得非常清楚，
翻译得也很不错，没有给理解带来障碍。
书中描述的是作者在上个实际60年代管理大型软件工程项目的一些经验和看法，
可是这些观点拿到现在来看也仍然没有过时。
我在此总结一些我比较有体会的观点，并谈谈我的一些体会。</p>

<h2 id="section">人月神话</h2>

<p>首先是和书名对应的这个观点——“人月神话”，
意思是说尽管一个项目的工作量可以用人月来衡量，
但是“人”和“月”这两个量度并不是可以互换的，
也就是说不能通过增加更多的人手来减少项目完成所需要的时间。
这主要是由于两方面的原因：</p>

<ul>
  <li>有些任务由于次序上的限制不能分解，
也就是说不能把一个任务分给两个人来做来减少一半的时间。</li>
  <li>增加了一个人员就增加了培训和交流的成本。</li>
</ul>

<p>因此，作者提出了Brooks法则：</p>

<blockquote>
  <p>向进度落后的项目中增加人手，只会使进度更加落后。</p>
</blockquote>

<p>这就是除去了神话色彩的人月。</p>

<h2 id="section-1">概念完整性</h2>

<p>概念完整性是指整个系统的设计具有一致性，系统只反应唯一的设计理念。
这要求系统的设计必须由一个人，或者非常少数互有默契的人员来实现。
在本书中，作者希望按照“外科手术队伍”的形式来组织团队，
团队的首席程序员类似于外科手术队伍的医生，他定义系统的功能，
设计程序，编制源代码，其他的人员负责给首席程序员提供必要的帮助。
或者，可以对设计方法和具体实现进行分工，
由架构师来完成设计，制定好技术说明，而实现人员负责实现。</p>

<p>概念完整性是如此重要，我所知的成功的软件项目都是反应了一两个天才程序员的理念，
由他们来决定整个项目的走向。</p>

<h2 id="section-2">没有银弹</h2>

<p>这是本书中一个颇具争议的观点：</p>

<blockquote>
  <p>在未来十年内，无论是在技术还是管理方法上，
都看不出有任何突破性的进步，
能够独立保证在十年内大幅度地提高软件的生产率、可靠性和简洁性。</p>
</blockquote>

<p>首先，作者把软件项目的开发过程分为两部分：</p>

<ul>
  <li>根本任务，打造构成抽象软件的复杂概念结构，我理解就是完成软件的设计。</li>
  <li>次要任务，使用编程语言表达这些抽象实体，也就是完成实现。</li>
</ul>

<p>作者认为，现在的技术或管理方法的革新，只能改进次要任务的生产率，
而根本任务的难度并没有发生改变。这样，除非次要任务能够占到所有工作的9/10以上，
否则总体的生产率不会有数量级的提升。</p>

<p>那为什么根本任务的生产率无法提高呢？这是由于开发软件系统需要面对这些无法规避的问题：</p>

<ul>
  <li>
    <p>复杂度。一个软件系统有大量的状态，存在大量不同元素的相互叠加。
这使得软件系统的复杂性以指数的形式增长。而且，这些复杂度是软件系统的根本属性，
而不像数学和物理中那样可以建立简化的模型而忽略复杂的次要因素。</p>
  </li>
  <li>
    <p>一致性。复杂度的问题不只是软件工程师才会面对，物理学家也会面临复杂度的问题。
但是他们相信能够建立一个通用的理论将这些复杂性统一起来，因为整个宇宙的规律是由上帝创造的，
而上帝不是反复无常的。而软件工程师需要控制的复杂度是随心所欲，毫无规律可言的，
需要遵循人为惯例和系统约束，需要和这些系统保持一致。
（可以这样理解，这些复杂度是由不同的PM带来的，我没有黑PM啊。。）</p>
  </li>
  <li>
    <p>可变性。有两个因素导致软件需要经常发生变化，
一是软件系统改变的容易性使得有更多改变的需求（PM说，不就是改两行代码吗？
他绝不会轻易让人去改装一辆生产好的汽车）；二是软件的寄主（操作系统，硬件）经常发生变化，
使得软件需要改变。</p>
  </li>
  <li>
    <p>不可见性。这一点我不是很理解，可能随着图形界面的提出，
软件的可见性能够得到很大程度的改善吧。</p>
  </li>
</ul>

<p>似乎，作者提出的这些问题40年后仍然没有得到解决，
对抗软件复杂性和可变性一个比较好的方式是快速原型，然后不断迭代。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/31/2013-summary/">2013年终总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-31T21:56:00+08:00" pubdate data-updated="true">Dec 31<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>还是踩着年末的尾巴发一篇年终总结吧。</p>

<p>2013对我来说不是平淡的一年。
这一年，我大学毕业，从一所大学来到另外一所大学，
分别原来的同学和朋友，
又在新的地方建立起了人际关系网；
这一年，我从大学生变成了研究生，
伴随着学历的增长，我的生活节奏也完全发生变化，
现在的我，开始沉下心来学习一些东西，
虽然现在仍然没有很大的成果。
这一年，我和她吵了不知道多少次架，
每次都是因我而起，我心里十分愧疚，
我现在仍然不够成熟，
心胸不够开阔。</p>

<h2 id="section">计划的完成程度</h2>

<blockquote>
  <p>多看书，多感受生活，开阔自己的胸襟</p>
</blockquote>

<p>虽然这被放在了计划的第一条，但是完成的最不好。
这里的“看书”，当然是说非专业的书籍，
印象当中就看了《天龙八部》和《唐浩明评点曾国藩家书》（上下册），
家书下册还是这两天逼迫自己看完的，
看书之少，现在都替自己不好意思。</p>

<p>至于修身，也没有花多少功夫，
否则也不至于跟女朋友吵那么多架。
没有把这个放在比较重要的位置，
仍然还是我行我素，
只知道在专业方面努力，
其他方面都不在乎。
这一点，在来年必须要改。</p>

<blockquote>
  <p>学习一门新的编程语言，可能是go或者erlang</p>
</blockquote>

<p>也完成的不是很好，大概的学习了一下go(完成了go tour)，
没有用它写过实际的项目。</p>

<blockquote>
  <p>学完完有关数据挖掘的基础知识</p>
</blockquote>

<p>这个完成得还不错，
掌握了很多的机器学习和数据挖掘方面的基础知识。
完成了毕业设计，使用scikit-learn开发过机器学习程序，
写了很多实现机器学习算法的matlab代码。
上了两门机器学习的课程，一门是浙大蔡登老师上的，
另一门是Coursera上的。</p>

<blockquote>
  <p>为github上的一个库提交代码</p>
</blockquote>

<p>为<a href="https://github.com/easychen/TeamToy-Plugins">TeamToy-Plugin</a>这个项目写了两个插件，
一个是OpenId的，一个是创意墙（团队用户可以在上面分享创意，使用类似于Hacknews的排序，
这个插件没有提交）。</p>

<p>这个计划完成程度也不是很满意，投入的时间太少了。</p>

<h2 id="section-1">计划之外</h2>

<h3 id="section-2">专业书</h3>

<p>2013年在专业方面的投入还是蛮多的，
看过的书不能算少，也不能算多：</p>

<ol>
  <li>
    <p>《The C Programming Language》，这仅仅只有200多页的书，
除了让我知道如何写出好的C程序之外，
也让我明白了如何如何精简地表达自己的观点。</p>
  </li>
  <li>
    <p>《The CPP Programming Language》，以前一直对这本书持保留看法，
觉得这么厚的一本书一定晦涩难懂，
直到我认认真真地把整本书都看了一遍，
才发现这是一本不可多得的好书。
整本书讲解清晰，
把C++这么复杂的一门语言的语言特性阐释得十分清楚，
而且，里面还有很多如何写出更好的程序的技巧，
很多时候作者的很多思想会引起我强烈的共鸣，
或者启发我深度的思考。</p>
  </li>
  <li>
    <p>《Introduction to Data Mining》，
这本书总体感觉是介绍性质的，里面设计的理论不是很深，
数学讲解不是很多，不过能从中知道数据挖掘的各个方面。
可能Jiawei Han老师的那本数据挖掘更好一些。</p>
  </li>
  <li>
    <p>《Pattern Classification》，
这本书是上机器学习课程的主要教材，
里面的理论讲得很深，
是一本比较好的参考书。</p>
  </li>
  <li>
    <p>《The Practice of Programming》,
看这本书，完全是冲着Robert Pike的大名去的，
看完之后果然不失所望，
学到了很多的编程方法，
只是这本书的评注实在让人哭笑不得。</p>
  </li>
  <li>
    <p>《Effective Java》,
这本书看的是中文版，
翻译得不是很好，
有少数几个地方有点难以理解。
由于以前写的Java程序太少，
看完这本书之后收益还是蛮大的，
至少现在知道怎么去写Java程序了，
同时对于面向对象的特性也有了更加深入的理解。</p>
  </li>
</ol>

<p>应该说，今年看书确实比以往有所长进，
因为看完书之后能够对它进行总结，
其中一些重要的观点和思想都记录下来，
而不是看完就忘记了。
我觉得这是一种很好的看书方法，
看书不应该一味的追求速度，
看完之后的总结很有必要。</p>

<h3 id="coding">Coding</h3>

<p>2013年写过的代码不能算多，写的代码是PHP和Python，
但是有时候也看一些其它语言的书和文章，
然后拿着这些特性来进行一个比较，
想得比较多。同时，
有时需要写一些代码来测试一些有趣的语言特性，
这些代码可以作为以后的参考。</p>

<p>同时，今年看了几个开源项目的代码，
包括scrapy和redis，
看这些代码一方面能够开阔自己的视野，
另一方面对于如何写程序也能够有所体会。</p>

<h3 id="paper">Paper</h3>

<p>2013年也看过一些论文，
包括google的三大论文，
还有graphlab的4篇论文，
Spark的两篇论文。
对于后面的两种论文，
现在理解还不是很深入，
幸亏存在开源的代码能够加深理解。</p>

<p>在机器学习方面也看过一些论文，
其中推荐系统和聚类方面的论文看得比较多。</p>

<h2 id="section-3">2014年计划</h2>

<ol>
  <li>修身仍旧还是第一位，而且必须要花一定的时间。</li>
  <li>多看书，多看非专业书。</li>
  <li>看完Graphlab和Spark的源码, 期间需要巩固C++和学习Scala。</li>
  <li>上完Convex Optimization、Probabilistic Graphical Models
和Neural Networks for Machine Learning这三门在线课程。</li>
  <li>在github上为开源项目提交代码。</li>
</ol>

<p>祝愿所有人新年快乐，新的一年实现自己的梦想。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/24/bigtable/">Bigtable 学习心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-24T20:49:00+08:00" pubdate data-updated="true">Oct 24<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">基本介绍</h2>

<p>Bigtable是一个分布式的数据库，
它的出现主要是因为传统的关系型数据库在面对大量数据（PB级别）时不具有扩展性。
Bigtable在谷歌内部得到了广泛使用，
<a href="http://hbase.apache.org/">Apache HBase</a>是它的开源实现。</p>

<h3 id="section-1">数据格式</h3>

<p>可以把一个Bigtable当成一个持久化的，分布式的，多维的map。
它的值通过<code>(rowkey, columnkey, timestamp)</code>来索引。
其中<code>rowkey</code>，<code>columnkey</code>和值都可以是任意的字符串。
如下图所示。</p>

<p><img src="/images/row_column.jpg" alt="Bigtable数据示意图" /></p>

<p>在上图中，<code>rowkey</code>是<code>com.cnn.www</code>。
在Bigtable中，对row的操作是原子(atomic)的。
在Bigtable中，数据的保存顺序是通过<code>rowkey</code>的字典序来维持的，
基于这个特点，可以通过挑选合适的<code>rowkey</code>把相关的数据放在一起。
比如上图，通过使用倒序的主机名作为<code>rowkey</code>，
可以把同一域名下的网页放在一起。
几个row组合起来形成一个tablet，
一个table由一个或多个tablet组成。</p>

<p><code>columnkey</code>通过<code>column family</code>来进行划分，
如上图，anchor就是一个<code>column family</code>，它有两个<code>column key</code>：
<code>anchor:cnnsi.com</code>和<code>anchor:my.look.cn</code>。
contents也是一个<code>column family</code>, 它只有一个<code>column key</code>，
就是<code>contents:</code>。<code>column family</code>是访问控制的基本单位。
每一个<code>column key</code>必须以<code>column family:qualifier</code>的格式命名。</p>

<p>对于同一个<code>rowkey</code>和<code>columnkey</code>的组合，
Bigtable根据不同的<code>timestamp</code>保存了不同的值。
通常，会保存最近的几个版本（具体的版本数用户可以指定），
过期的数据会被垃圾回收掉。</p>

<h3 id="api">API</h3>

<p>Bigtable的API非常简单，下面是两个使用API的例子： </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>写Bigtable</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">// Open the table</span>
</span><span class="line"><span class="n">Table</span> <span class="o">*</span><span class="n">T</span> <span class="o">=</span> <span class="n">OpenOrDie</span><span class="p">(</span><span class="s">&quot;/bigtable/web/webtable&quot;</span><span class="p">);</span>
</span><span class="line"><span class="c1">// Write a new anchor and delete an old anchor</span>
</span><span class="line"><span class="n">RowMutation</span> <span class="n">r1</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s">&quot;com.cnn.www&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">r1</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="s">&quot;anchor:www.c-span.org&quot;</span><span class="p">,</span> <span class="s">&quot;CNN&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">r1</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span><span class="s">&quot;anchor:www.abc.com&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">Operation</span> <span class="n">op</span><span class="p">;</span>
</span><span class="line"><span class="n">Apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的代码段对<code>rowkey="com.cnn.www"</code>的行，
将<code>columnkey="anchor:www.c-span.org"</code>的列的值设置为<code>CNN</code>，
同时删除<code>columnkey = "anchor:www.abc.com"</code>的列。其中<code>Apply()</code>是原子操作。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>读Bigtable</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="n">Scanner</span> <span class="n">scanner</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span><span class="line"><span class="n">ScanStream</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>
</span><span class="line"><span class="n">stream</span> <span class="o">=</span> <span class="n">scanner</span><span class="p">.</span><span class="n">FetchColumnFamily</span><span class="p">(</span><span class="s">&quot;anchor&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">stream</span><span class="o">-&gt;</span><span class="n">SetReturnAllVersions</span><span class="p">();</span>
</span><span class="line"><span class="n">scanner</span><span class="p">.</span><span class="n">Lookup</span><span class="p">(</span><span class="s">&quot;com.cnn.www&quot;</span><span class="p">);</span>
</span><span class="line"><span class="k">for</span> <span class="p">(;</span> <span class="o">!</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">Done</span><span class="p">();</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s %s %lld %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">            <span class="n">scanner</span><span class="p">.</span><span class="n">RowName</span><span class="p">(),</span>
</span><span class="line">            <span class="n">stream</span><span class="o">-&gt;</span><span class="n">ColumnName</span><span class="p">(),</span>
</span><span class="line">            <span class="n">stream</span><span class="o">-&gt;</span><span class="n">MicroTimestamp</span><span class="p">(),</span>
</span><span class="line">            <span class="n">stream</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">());</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的代码段遍历<code>rowkey="com.cnn.www"</code>的行中<code>column family="anchor"</code>的所有列的所有版本。</p>

<h2 id="section-2">实现</h2>

<p>Bigtable使用了几个部件构建而成：</p>

<ul>
  <li>GFS，Bigtable的底层依赖GFS，它使用GFS来保存数据和commit log，马上就会讲述细节。</li>
  <li>
    <p>Chubby，是Google发布的另外一个分布式系统，它具体的原理我还没有去看那篇论文，
  现在只需要知道Bigtable使用Chubby来完成下面的事情：</p>

    <ul>
      <li>保证任何时候只有一个bigtable master server</li>
      <li>存放Bigtable最开始的数据，用于定位METADATA，接下来会看到。</li>
      <li>用于监控tablet server的状态</li>
      <li>存放schema</li>
      <li>存放ACL(access control list)</li>
    </ul>

    <p>Chubby对于Bigtable非常重要，如果它停止工作了，
  那么整个Bigtable也停止工作。
  Chubby的开源实现是<a href="http://zookeeper.apache.org/">ZooKeeper</a>，
  下次再来研究Chubby。</p>
  </li>
</ul>

<h3 id="section-3">组成部分</h3>

<p>和GFS类似，Bigtable也由三个部分组成，分别是:</p>

<ul>
  <li>client：用于和应用程序交互</li>
  <li>一个master: 管理整个系统，要做的工作包括分配tablet，
负载均衡，垃圾回收，处理schema的变化。</li>
  <li>很多的tablet server：一个tablet server负责多个tablet，
client对于tablet的读写请求直接与tablet server进行交互。</li>
</ul>

<p>需要注意的是，与GFS不一样，
关于tablet的位置信息client不需要通过master就可以知道(接下来就会提到)，
所以大部分情况下client都不需要和master交互，
这样master上的压力更小了。</p>

<h3 id="tablet">Tablet的位置</h3>

<p>Bigtable使用一个三层的结构来存放tablet的位置，
如下图所示。(论文上说这个和B+树比较像，
我倒觉得用inode来类比更加好理解)</p>

<p><img src="/images/tablet_location_hierarchy.png" alt="" /></p>

<p>首先，一个Chubby File保存了root tablet的位置。
root tablet是一个特殊的METADATA table，
它保存了所有其他METADATA tablet的位置。
每一个METADATA又保存了user tablet的位置。
所以，顺着这个结构走下来，就能找到任意的tablet的位置。</p>

<p>关于这个“位置”，我是这样理解的，
它应该是一个具体的tablet server的名字，
client知道了哪个tablet server之后就向那个tablet server发出请求。
如果是这样的话，把tablet重新分配之后master需要去更新这些保存位置的tablet。</p>

<p>这里还有几个计算：</p>

<ul>
  <li>如果一行占的空间是1KB，一个tablet的空间是128MB，
那么这样一个三层的结构能够保存的tablet的数目为$2^{34}$，
这个很容易理解，128MB / 1KB = $2^{17}$，两级下来就是$2^{34}$。</li>
  <li>客户端会缓存住tablet的location，这样就不用每次都去读这个层级的结构。
如果客户端没有缓存，那么它读取一个tablet需要3次和tablet server的交互
（读root，METADATA，user tablet各一次)。如果缓存过期了，
最多需要6次和tablet server的交互（对于这个，我的理解是，如果客户端缓存了root tablet的location,
但是它过期了，那么它首先顺着这个结构下去，需要3次，然后发现不对，
又重新向Chubby得到root的位置，又再次顺着这个结构下去3次，
一共6次）。</li>
</ul>

<h3 id="tablet-1">Tablet的分配</h3>

<p>一个tablet一次只会被分配给一个tablet server，
master保存下面的信息：</p>

<ul>
  <li>哪些tablet server是正常工作的（alive）</li>
  <li>哪些tablet被分配给哪些tablet server</li>
  <li>哪些tablet没有被分配（这个只是暂时的，master会把这些tablet分配好，外面看不到这个状态？）</li>
</ul>

<p>当一个tablet server启动时，
它会去获取Chubby的某个特定目录下的一个文件（一个tablet server唯一的对应这个目录下的一个文件）的互斥锁。
master通过检查这个目录查看哪些tablet server是alive的。
tablet server如果丢失了这个互斥锁，那么它会尝试重新获取，
如果这个文件不存在了，tablet server永远都拿不到这个锁了，
那么它会自动停止。
如果tablet server不工作了，它会释放这个锁，
这样master就知道它没有工作了，把它上面的tablet分配给其他的tablet server。</p>

<p>master会频繁地和那些正常工作的tablet server进行通信来获取它们的状态，
如果tablet server告诉master它失去了锁或者无法和这个tablet server进行通信，
那么master会尝试获取这个tablet server对应的文件锁，
如果能够拿到这个锁，说明Chubby能正常工作，
而这个tablet server要么死掉了要么不能和Chubby交互，
那么master就删除这个tablet server对应的文件，
这样这个tablet server就没用了，
然后master把这个tablet server上的tablet分配给其他的tablet server。</p>

<p>在master启动时，它会执行下面的步骤：</p>

<ol>
  <li>首先，它会去Chubby上获取master锁，确保同一时间只有一个master工作</li>
  <li>然后，扫描Chubby上的目录（就是上面提到的目录，所有tablet server对应的文件都在这个目录下），
知道哪些tablet server是alive的</li>
  <li>然后，和每个alive的tablet server交互，知道哪些tablet已经被分配了</li>
  <li>最后，便利tablet位置的三层结构（Figure 4），知道一共有哪些tablet，
然后把这些tablet分配给tablet server。</li>
</ol>

<p>这里有一个问题是，如果METADATA的tablet没有被分配，
那么它就不能被读取，那么第4步就没法进行了。
这个问题可以这样解决，如果需要读取某个tablet时它还没有被分配，
那么先把它分配给某个tablet server，然后就可以继续接下来的步骤。</p>

<p>当下面的情况发生时，tablet的分配情况要进行调整：</p>

<ul>
  <li>tablet被创建或删除</li>
  <li>tablet被合并</li>
  <li>tablet被切分成两个tablet</li>
</ul>

<p>前面两种情况都是在master进行的，所以master直接进行调整就行，
而第三种过程是在某个tablet server上进行的，
master怎么知道的呢？
当tablet server对tablet进行切分时，
它首先在METADATA的tablet上记录下这个新的tablet，
然后通知master发生了改变。
如果这个通知丢失了，
那么当master去请求这个被切分的tablet时，
tablet server会发现这个tablet的METADATA table只是请求的METADATA的一部分，
就知道发生了切分，然后告诉master。</p>

<h3 id="tablet-2">Tablet的保存</h3>

<p>下面来看下一个tablet具体是如何保存的。</p>

<p><img src="/images/tablet_representation.png" alt="Tablet的表示" /></p>

<p>根据<a href="http://www.nosqlnotes.net/archives/122">这篇博客</a>，
要保存一个tablet，有这么几个部分：</p>

<ul>
  <li>主SSTable，就是持久化的不可变的哈系表，保存在GFS上</li>
  <li>memtable，在内存中记录最近的修改操作</li>
  <li>commit log，修改记录，分为compacted和uncompacted（待会会说明）</li>
  <li>次SSTable(为了区分两种SSTable，我用了“主”， “次”，不是重要性的区分)，
这种SSTable是memtable的持久化版本，次SSTable的存在是为了加快recovery的速度，
因为recovery需要从commit log恢复memtable，同时可以释放memtable的内存</li>
</ul>

<p>有了这几个部分，对tablet的操作也就变得容易了，
对于写操作，只需要记录把操作记录在commit log中，
同时写入memtable。对于读操作，
由于数据不仅仅保存在主SSTable上，
还需要结合memtable和次SSTable来进行。</p>

<h3 id="compactions">Compactions</h3>

<p>Compaction主要是为了解决上面过程中出现的问题，它分为3种：</p>

<ul>
  <li>minor compaction: 这个操作就是把memtable中的内容保存到SSTable,
释放memtable的内存，同时减小recovery时需要读取的commit log的数目，
已经被保存到次SSTable上的操作对应的commit称为compacted，
recovery时只需要从uncompacted的commit log中恢复就行了。 </li>
  <li>merge compaction: 
因为每次读取操作时都需要读取主SSTable和相关的次SSTable，
所以次SSTable的数量不能太多，因此，
master会把一些次SSTable组合成一个新的次SSTable。</li>
  <li>major compaction: 
master把次SSTable和memtable中的内容整合到SSTable里，
这样，就能回收掉修改的和删除的记录所占的空间。</li>
</ul>

<h2 id="section-4">优化</h2>

<h3 id="locality-groups">Locality groups</h3>

<p>client可以把一些列组放在一起形成一个locality group,
在每一个tablet里面，会为每一个locality group生成一个单独的SSTable,
使用locality group的好处是：</p>

<ul>
  <li>可以提高读的性能，比如把网页的contents放在一个locality group，
而metadata放在另外一个locality group，
这样读取metadata时就不需要读取网页的内容。</li>
  <li>可以对于不同的locality采取不同的调优参数。比如，
可以把有些locality group的SSTable放入内存。</li>
</ul>

<h3 id="cache">Cache</h3>

<p>为了提高读性能，tablet server采用了两种级别的cache:</p>

<ol>
  <li>Scan Cache，缓存从SSTable返回的key-value对</li>
  <li>Block Cache，缓存从GFS读回来的SSTable的block</li>
</ol>

<h3 id="bloom-filters">Bloom filters</h3>

<p>读操作需要结合SSTable和memtable，因此，
可以通过bloom filter来制定某些locality group的数据不可能存在于某些SSTable，
这样就可以减少需要读取的SSTable的数量。
Bloom filter一般保存在tablet server的内存中。</p>

<h3 id="commit-log">Commit log实现</h3>

<p>在Bigtable中，每一个tablet server只保存一个commit log, 
这个commit log保存了所有的tablet相关的log。这样做的好处是：</p>

<ul>
  <li>如果每个tablet一个commit log，就会导致同时有很多写请求发到GFS,
这样就会很多的磁盘seek。</li>
  <li>这样限制了group commit的作用，
因为只有同一个tablet的写操作才能被合并成一个到一个group commit。</li>
</ul>

<p>所有tablet的commit log组合成一个文件增加了恢复的复杂性，
因为这样不同的tablet可能被迁移到不同的tablet server，
这样所有相关的tablet server都需要读取这个commit log来获取tablet的信息，
这个commit log会被重复读多次。</p>

<p>解决这个问题的一个办法是在recovery时，
先把commit log使用<code>&lt;table, row name, log sequence number&gt;</code>作为key进行排序，
这样一个tablet的commit log就是连续的，可以通过一次seek，
然后连续读就可以得到。
这个排序的过程也可以通过把这个commit log分成几块，然后并发地进行排序来加快速度。</p>

<p>为了避免GFS集群中由于网络原因或者load情况带来性能上的波动，
通常使用两个线程来完成写commit log的操作，
每一个线程有自己的commit log文件，
同一时课只有一个线程在写，
如果一个线程写出现了性能上的问题，
就切换到另外一个线程（因为两个线程使用了不同的文件，
可能分布到不同的chunkserver）。同时，
使用序列号来消除重复的commit log。</p>

<h3 id="recovery">加快recovery</h3>

<p>如果master把tablet从一个tablet server移到另一个，
源tablet server可以进行一次minor compaction，
这样uncompacted的commit log就减少了很多，
因为这个过程中可能会有其他的写操作，
所以在upload这个tablet时，
可以再进行一次非常快的minor compaction，
这样就不要进行recovery了。</p>

<h3 id="section-5">不变性</h3>

<p>利用SSTable的不可变性带来了以下的方便：</p>

<ul>
  <li>缓存。</li>
  <li>memtable是唯一可变的数据结果，对它使用<a href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>来消除读写冲突。</li>
  <li>回收垃圾只需要回收SSTable就好了。</li>
  <li>在split时，child tablet可以使用parent tablet的SSTable。</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/21/migrate-to-octopress/">把博客迁到Octopress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-21T20:02:00+08:00" pubdate data-updated="true">Oct 21<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>折腾了一个下午，终于把博客迁到到了Octopress。
迁移的原因主要有两点：</p>

<ul>
  <li>
    <p>喜欢Octopress整体的风格，包括它的响应式设计，
还有特别好看的<code>solarized</code>的语法高亮。</p>
  </li>
  <li>
    <p>以前在<code>jekyll</code>上写博客，在<code>github</code>上面开了两个库，
原因在于Github Pages上不允许运行ruby脚本，
这样很多功能包括分页就都不能做了。为了完成分页的目的，
我在一个库里保存博客的源代码，使用<code>jekyll</code>来生成静态页面，
然后另一个库也就是<code>chouqin.github.io</code>就完全是静态页面，
把它发布到Github Pages上去。Octopress也是这样，
只不过它省去了我的麻烦，要发布到Github Pages，
只要一条<code>rake deploy</code>就够了，非常方便。</p>
  </li>
</ul>

<p>来说一下具体的迁移过程吧。</p>

<h2 id="section">基础博客搭建</h2>

<p>其实完全是照着Octopress的<a href="http://octopress.org/docs/setup/">官方文档</a>一步步安装过来的，
官方博客已经写得很清楚了。Ruby管理使用的是<a href="http://rvm.io">rvm</a>。</p>

<p>出现了一个问题是<code>rake</code>安装的是10.1.0的版本，跟Gemfile对应的不一致，
直接把Gemfile里的那行改为<code>gem 'rake', '~&gt; 10.1.0'</code>。</p>

<h2 id="section-1">修改配置</h2>

<p>首先是按照文档修改了一些<code>_conf.yml</code>配置:</p>

<ul>
  <li>把使用的markdown改为<code>kramdown</code></li>
  <li>启用<code>pygments</code>来进行语法高亮</li>
  <li>Aside Bar只显示最近的Post和Github。</li>
  <li>配置了<code>disqus_short_name</code>。</li>
</ul>

<p>具体的配置可以查看我的<a href="https://github.com/chouqin/chouqin.github.io/tree/source">github</a></p>

<h3 id="mathjax">使用MathJax</h3>

<p>由于使用的是<code>kramdown</code>，它的语法包含数学，为了在页面上展示数学公式，
在<code>source/_includes/head.html</code>上加入以下的内容：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="html"><span class="line"><span class="c">&lt;!-- mathjax config similar to math.stackexchange --&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-mathjax-config&quot;</span><span class="nt">&gt;</span>
</span><span class="line">  <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Config</span><span class="p">({</span>
</span><span class="line">    <span class="nx">tex2jax</span><span class="o">:</span> <span class="p">{</span>
</span><span class="line">      <span class="nx">inlineMath</span><span class="o">:</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;$&#39;</span><span class="p">,</span><span class="s1">&#39;$&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;\\(&quot;</span><span class="p">,</span><span class="s2">&quot;\\)&quot;</span><span class="p">]</span> <span class="p">],</span>
</span><span class="line">      <span class="nx">processEscapes</span><span class="o">:</span> <span class="kc">true</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">});</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-mathjax-config&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Config</span><span class="p">({</span>
</span><span class="line">      <span class="nx">tex2jax</span><span class="o">:</span> <span class="p">{</span>
</span><span class="line">	<span class="nx">skipTags</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;script&#39;</span><span class="p">,</span> <span class="s1">&#39;noscript&#39;</span><span class="p">,</span> <span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="s1">&#39;textarea&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;code&#39;</span><span class="p">]</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/x-mathjax-config&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">Queue</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">	<span class="kd">var</span> <span class="nx">all</span> <span class="o">=</span> <span class="nx">MathJax</span><span class="p">.</span><span class="nx">Hub</span><span class="p">.</span><span class="nx">getAllJax</span><span class="p">(),</span> <span class="nx">i</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">all</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	    <span class="nx">all</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">SourceElement</span><span class="p">().</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">className</span> <span class="o">+=</span> <span class="s1">&#39; has-jax&#39;</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span>
</span><span class="line">   <span class="na">src=</span><span class="s">&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span><span class="nt">&gt;</span>
</span><span class="line"><span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">迁移原来的博文</h2>

<p>原来的博客是基于<code>jekyll</code>的，对于每一篇博客，修改这几个地方即可：</p>

<ul>
  <li>删除掉前面的<code>Included file 'JB/setup' not found in _includes directory</code>。</li>
  <li>在配置上加入<code>comments: true</code>。</li>
</ul>

<h2 id="section-3">发布到七牛</h2>

<p>因为生成的是静态页面，所以也可以发布到七牛来加速访问。
在部署之前，你需要先<a href="https://portal.qiniu.com/signup?code=3l94gjc9mqzwx">注册</a>成为七牛用户，
然后获取<a href="https://portal.qiniu.com/setting/key">AccessKey 和 SecretKey</a>。</p>

<p>然后安装七牛的<a href="http://docs.qiniu.com/tools/v6/qrsync.html">qrsync</a>。</p>

<p>在<code>octopress</code>目录下创建<code>qiniu.conf</code>，写入以下内容:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="json"><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="nt">&quot;access_key&quot;</span><span class="p">:</span> <span class="s2">&quot;Please apply your access key here&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;secret_key&quot;</span><span class="p">:</span> <span class="s2">&quot;Dont send your secret key to anyone&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;bucket&quot;</span><span class="p">:</span> <span class="s2">&quot;Bucket name on qiniu resource storage&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;sync_dir&quot;</span><span class="p">:</span> <span class="s2">&quot;_deploy&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;async_ops&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="nt">&quot;debug_level&quot;</span><span class="p">:</span> <span class="mi">1</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后执行<code>qrsync qiniu.conf</code>，就能部署到七牛了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/16/mapreduce/">MapReduce学习心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-16T00:00:00+08:00" pubdate data-updated="true">Oct 16<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">简介</h2>

<p>对于计算机系的同学来说，MapReduce这个词应该并不陌生，
现在是所谓的“大数据时代”，“大数据”这个词被炒得非常热。
何为“大数据”？随着互联网的发展，现在的数据越来越多，
给原先的技术带来了两方面的挑战，一是<strong>存储</strong>，
如何存储这些PB级别的数据，
二是<strong>分析</strong>， 如何对这么大的数据进行分析，
从中提取出有用的信息。</p>

<p>MapReduce就是一个对大数据进行分析的框架。
使用MapReduce，用户只需要定义自己的<code>map</code>函数和<code>reduce</code>函数，
然后MapReduce就能把这些函数分配到不同的机器上去并行的执行，
MapReduce帮你解决好调度，容错，节点交互的问题。
这样，一个没有分布式系统编程经验的人也可以利用MapReduce把自己的程序放到几千台机器上去执行。</p>

<p><code>map</code>和<code>reduce</code>都是来自于函数式编程的概念，<code>map</code>函数接受一条条的纪录作为输入，
然后输出一个个<code>&lt;key, value&gt;</code>对，<code>reduce</code>函数接受<code>&lt;key, values&gt;</code>对，
（其中<code>values</code>是每一个<code>key</code>对应的所有的<code>value</code>)，通过对这些<code>values</code>进行一个“总结”，
得到一个<code>&lt;key, reduce_value&gt;</code>。</p>

<p>比如拿经典的<strong>WordCount</strong>例子来说，对于文本中的每一个单词<code>word</code>，
<code>map</code>都会生成一个<code>&lt;word, 1&gt;</code>对（注意如果一个文本中一个单词出现多次就生成多个这样的对）,
<code>reduce</code>函数就会收到<code>&lt;word, 1,...&gt;</code>这样的输入，它的工作就是把所有的<code>1</code>都加起来，
生成一个<code>&lt;word, sum&gt;</code>。</p>

<p>MapReduce函数基于键值对进行处理，看起来很简单，
那很多的分析任务不仅仅只是简单的Wordcount而已，能够使用这两个函数来实现吗？
幸运的是，很多的大规模数据分析任务都能通过MapReduce来表达，
这也是为什么MapReduce能够作为一个框架被提出的原因，
在最后一个部分中会给出一些更加复杂的使用MapReduce的例子。</p>

<h2 id="section-1">架构</h2>

<p>在大概了解了MapReduce之后，我们来看一下它到底是怎么实现的。
我们首先看一下一个MapReduce任务执行完需要经过那些流程，
然后再看一下在实现MapReduce的时候需要考虑的几个因素。</p>

<h3 id="section-2">基本流程</h3>

<p><img src="/images/map_reduce_execution.png" alt="" /></p>

<p>我们首先假定把一个任务分成M个<code>map</code>Task和R个<code>reduce</code>task，
如上图,
整个任务的执行过程如下：</p>

<ol>
  <li>
    <p>首先根据<code>map</code>的数量把原来的数据分成M个splits，每一个split对应一个<code>map</code>task。</p>
  </li>
  <li>
    <p>在集群的节点上启动<code>master</code>，M个<code>map</code>task和N个<code>reduce</code>task, 
<code>master</code>把split分配给相应的<code>map</code>task。需要注意的是，
一个集群的节点（又称作一个worker）上可能有多个<code>map</code>task,
也有可能<code>map</code>task和<code>reduce</code>task在同一个worker。</p>
  </li>
  <li>
    <p>每一个<code>map</code>task读取自己的split，根据用户定义的<code>map</code>函数生成<code>&lt;key value&gt;</code>对，
把结果保存在<strong>本地文件</strong>中，
根据<code>key</code>的不一样，结果被写入到R个不同的文件。
这些文件的位置会告知给<code>master</code>，然后<code>master</code>再告知给相应的<code>reduce</code>task。</p>
  </li>
  <li>
    <p>当一个<code>reduce</code>task被告知这些文件的位置时，它通过远程调用读取这些文件的内容，
当和这个<code>reduce</code>task相关的所有文件都被读到之后，它把这些内容按照<code>key</code>进行一个排序，
然后就能保证同一个<code>key</code>的所有<code>values</code>同时被传给<code>reduce</code>。</p>
  </li>
  <li>
    <p><code>reduce</code>task使用用户定义的<code>reduce</code>函数处理上述排序好的数据，
将最终的结果保存到一个<strong>Global File System</strong>（比如GFS），
这是为了保证数据的可靠性。</p>
  </li>
</ol>

<h3 id="section-3">文件的保存</h3>

<p>在上述的过程中，我们看到<code>map</code>task的结果被保存在本地，
而把<code>reduce</code>task的结果保存在具有可靠性保证的文件系统上。
这是因为<code>map</code>task产生的是中间结果，当这些结果被<code>reduce</code>之后，
就可以被扔掉，不需要备份，这样可以节约磁盘空间。
而<code>reduce</code>task产生的是最终结果，需要一定的可靠性保证。</p>

<h3 id="split">split的粒度</h3>

<p>在对一个任务进行划分时，需要考虑split的粒度：</p>

<ul>
  <li>
    <p>如果split太小，M就会很大，
<code>master</code>需要纪录的数据就会很多，
就会消耗很多<code>master</code>的内存。</p>
  </li>
  <li>
    <p>如果split太大，一方面调度不具有灵活性，
因为调度是以split为单位的，一个较大的task无法被分割放到其他空闲的worker上去执行。
另一方面无法利用<code>locality</code>进行调度，
因为<code>map</code>task的输入文件一般保存在分布式文件系统上，
<code>master</code>在调度时尽量把一个split分配到较近的节点上去执行，
如果split太大超过了一个文件block的大小，
这样可能两个block在不同的节点上，甚至跨了不同的机架，
这样无法利用<code>locality</code>了。</p>
  </li>
</ul>

<p>所以，在实际应用中，split的大小为一个block。</p>

<h3 id="section-4">容错</h3>

<p>由于MapReduce被分布到上千台机器上去执行，
错误是不可避免的。
MapReduc需要在节点发生故障时进行处理。</p>

<p>当一个节点发生故障，
在这个节点上的所有的<code>map</code>task都需要重新执行，
因为<code>map</code>task的结果是保存在节点本地的，
节点发生故障之后，这些结果就不可用了。
而成功执行的<code>reduce</code>task就不需要重新执行了，
因为它的结果是保存在分布式文件系统上，
可靠性是可以保证的。</p>

<h2 id="section-5">常见应用</h2>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h3 id="section-6">矩阵向量乘法</h3>

<p>假设有一个<script type="math/tex">m \times n</script>的矩阵M，
它和一个n维列向量v的乘积是一个m维的列向量x，有</p>

<script type="math/tex; mode=display">
x_i = \sum_{j=1}^{n} m_{ij}v_j
</script>

<p>可以根据j，把M按列分成k块，把v也对应分成k块，
每个M块和对应的v块被分给一个<code>map</code>task，
<code>map</code>task生成的结果为<script type="math/tex">(i, m_{ij}v_j)</script>对，
<code>reduce</code>task把每一个i对应的所有<script type="math/tex">m_{ij}v_j</script>加起来。</p>

<h3 id="section-7">关系代数运算</h3>

<p>关系数据库表的Join，Selection，Projection, Union, Intersection, 
Difference，Group And Aggregation等操作都可以使用MapReduce来实现。</p>

<p>值得一提的是，对于Join运算，比如链接关系R(a, b)和关系S(b, c)，
在生成以b为键的键值对时，需要指定来自于哪一个关系，
比如关系R生成的键值对的形式为<code>&lt;b, (R, a)&gt;</code>,
这样<code>reduce</code>时就可以根据这个信息进行组合。</p>

<h3 id="section-8">矩阵乘法</h3>

<p>假设有一个<script type="math/tex">m \times n</script>的矩阵M，
和一个<script type="math/tex">n \times p</script>的矩阵N，
它们的乘积是一个<script type="math/tex">m \times p</script>的矩阵P,
有:</p>

<script type="math/tex; mode=display">
p_{ik} = \sum_{j=1}^{n} m_{ij}n_{jk}
</script>

<p>矩阵M和矩阵N的乘法可以看成是关系M(I, J, V)和关系N(J, K, W)先进行一次Join，
再进行一次Group And Aggregation之后的结果，
因此可以直接通过两次MapReduce进行矩阵的乘法运算。</p>

<p>如果想要一次MapReduce就得到结果，可以在<code>map</code>时以(i, k)为键生成键值对，
同样的，需要指明来自于矩阵M还是矩阵N，因此，相应的键值对的格式分别为
<script type="math/tex">((i, k), (M, j, m_{ij}))</script>(对于矩阵M)，<script type="math/tex">((i, k), (N, j, n_{jk}))</script>(对于矩阵N)。
<code>reduce</code>时进行相应的组合。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/10/gfs/">GFS学习心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-10T00:00:00+08:00" pubdate data-updated="true">Oct 10<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>又好久没写博客了，这几个月来零零散散做了一些事情，
学到的东西很杂，一直都没有形成系统，也没有在某些方面有很深的体会。
有些东西刚刚深入进去看了一点（比如<a href="redis.io">redis</a>，看过一些代码，下次一定要写点心得出来），
还没来得及总结，就被一些其他的事情把时间挤走了。而现在，
时间相对来说比较空闲，可以认真研究一些技术，学得一些东西了。</p>

<p>这几天一直在看<a href="http://research.google.com/archive/gfs.html">The Google File System</a>这篇论文，
看得很慢，一天才能看几页，有些地方还要反反复复看几遍才能“理解”，
但也确实学得了不少东西，包括一些分布式系统设计的基本思想，
以及如何根据应用的具体场景来做设计决策。
诚然，对于一个这么大的系统，要想弄明白它的全部细节是比较困难的，
能够把它的整个过程捋顺就可以了。本文中，
我把我对这篇论文印象比较深的内容用我自己的理解讲出来，
希望能够给对GFS感兴趣的同学一点帮助。</p>

<h2 id="section">特殊的应用场景</h2>

<p>GFS作为一个分布式的文件系统，
除了要满足一般的文件系统的需求之外，
还根据一些特殊的应用场景（原文反复提到的<code>application workloads and technological environment</code>），
来完成整个系统的设计。</p>

<h3 id="section-1">分布式文件系统的要求</h3>

<p>一般的分布式文件系统需要满足以下四个要求：</p>

<ul>
  <li>Performance：高性能，较低的响应时间，较高的吞吐量</li>
  <li>Scalability: 易于扩展，可以简单地通过增加机器来增大容量</li>
  <li>Reliability: 可靠性，系统尽量不出错误</li>
  <li>Availability: 可用性，系统尽量保持可用</li>
</ul>

<p>（注：关于reliability和availability的区别，
请参考<a href="http://unfolding-mirror.blogspot.com/2009/06/reliability-vs-availability.html">这篇</a>）</p>

<h3 id="gfs">GFS基于的假设</h3>

<p>基于对实际应用场景的研究，GFS对它的使用场景做出了如下假设：</p>

<ol>
  <li>
    <p>GFS运行在成千上万台便宜的机器上，这意味着节点的故障会经常发生。
必须有一定的容错的机制来应对这些故障。</p>
  </li>
  <li>
    <p>系统要存储的文件通常都比较大，每个文件大约100MB或者更大，
GB级别的文件也很常见。必须能够有效地处理这样的大文件，
基于这样的大文件进行系统优化。</p>
  </li>
  <li>
    <p>workloads的读操作主要有两种：</p>

    <ul>
      <li>
        <p>大规模的流式读取，通常一次读取数百KB的数据,
 更常见的是一次读取1MB甚至更多的数据。
 来自同一个client的连续操作通常是读取同一个文件中连续的一个区域。</p>
      </li>
      <li>
        <p>小规模的随机读取，通常是在文件某个随机的位置读取
 几个KB数据。
 对于性能敏感的应用通常把一批随机读任务进行排序然后按照顺序批量读取，
 这样能够避免在通过一个文件来回移动位置。（后面我们将看到，
 这样能够减少获取metadata的次数，也就减少了和master的交互）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>workloads的写操作主要由大规模的，顺序的append操作构成。
一个文件一旦写好之后，就很少进行改动。因此随机的写操作是很少的，
所以GFS主要针对于append进行优化。</p>
  </li>
  <li>
    <p>系统必须有合理的机制来处理多个client并发写同一个文件的情况。
文件经常被用于生产者-消费者队列，需要高效地处理多个client的竞争。
正是基于这种特殊的应用场景，GFS实现了一个无锁并发append。</p>
  </li>
  <li>
    <p>利用高带宽比低延迟更加重要。基于这个假设，
可以把读写的任务分布到各个节点，
尽量保证每个节点的负载均衡，
尽管这样会造成一些请求的延迟。</p>
  </li>
</ol>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/10/10/gfs/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/20/markup-lang/">使用markdown和reStructuredText生成文档</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-04-20T00:00:00+08:00" pubdate data-updated="true">Apr 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">基本介绍</h3>
<p><a href="http://daringfireball.net/projects/markdown/">Markdown</a>和
<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>(下面简称rst)
是现在比较流行的<a href="http://en.wikipedia.org/wiki/Lightweight_markup_language">轻量级标注语言</a>，
这些语言拥有比较强大的表现力，可以通过简单的书写代码就可以写出包含代码，图片，数学公式等各种格式的文档。
这样，我们不用把心思花在各种格式的调节，而只需要专注于文档的内容就行了。
我们通过标记语言写成的文本文件能够被转化为html, tex, pdf，epub, word等各种格式，
我们只需要利用标记语言提供的语法把文本文件写好，相应的转换器会为你转换为特定的文档格式。
我的博客其实都是使用markdown一个特定版本<a href="http://kramdown.rubyforge.org/">kramdown</a>写的，
然后转换为html来发布。</p>

<p>学习这些标记语言其实很简单，远远比学习latex简单，把它提供的一些语法都写一遍，比如说怎么写标题，
怎么写列表，怎么插入代码，怎么插入数学符号等等。知道怎么写了之后，
就多练习，写得多了，熟悉之后就会发现，确实能够省去你控制格式的很多烦恼。</p>

<h3 id="pandoc">使用pandoc</h3>

<p>Markdown有很多超集，比如上面提到的kramdown，这些超集在markdown的基础之上有提供了一些功能，
比如说原生的markdown是不支持数学公式的，但kramdown支持，
它可以把你写在两个在源文件中的这样一段markdown代码:</p>

<div class="highlight"><pre><code class="tex"><span class="sb">$$</span><span class="nb"></span>
<span class="nb">O</span><span class="o">(</span><span class="nb">g</span><span class="o">(</span><span class="nb">n</span><span class="o">))</span><span class="nb"> </span><span class="o">=</span><span class="nb"> </span><span class="nv">\{</span><span class="nb">f</span><span class="o">(</span><span class="nb">n</span><span class="o">)</span><span class="nb">: </span><span class="nv">\exists</span><span class="nb"> c,n， </span><span class="nv">\forall</span><span class="nb"> n </span><span class="nv">\geq</span><span class="nb"> n_</span><span class="m">0</span><span class="nb">,  </span><span class="m">0</span><span class="nb"> </span><span class="nv">\leq</span><span class="nb"> f</span><span class="o">(</span><span class="nb">n</span><span class="o">)</span><span class="nb"> </span><span class="nv">\leq</span><span class="nb"> cg</span><span class="o">(</span><span class="nb">n</span><span class="o">)</span><span class="nv">\}</span><span class="nb"></span>
<span class="s">$$</span>
</code></pre></div>

<p>转化为这样一段html:</p>

<div class="highlight"><pre><code class="html"><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;math/tex; mode=display&quot;</span><span class="nt">&gt;</span>
    <span class="nx">O</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="o">=</span> <span class="err">\</span><span class="p">{</span><span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="o">:</span> <span class="err">\</span><span class="nx">exists</span> <span class="nx">c</span><span class="p">,</span><span class="nx">n</span><span class="err">，</span> <span class="err">\</span><span class="nx">forall</span> <span class="nx">n</span> <span class="err">\</span><span class="nx">geq</span> <span class="nx">n_0</span><span class="p">,</span>  <span class="mi">0</span> <span class="err">\</span><span class="nx">leq</span> <span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="err">\</span><span class="nx">leq</span> <span class="nx">cg</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="err">\</span><span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>

<p>包含这个的html<strong>如果里面包含<a href="http://www.mathjax.org/">MathJax</a>这个js库</strong>的话，
MathJax就会把上述的一段html转换为如下的数学公式呈现给你。</p>

<script type="math/tex; mode=display">
O(g(n)) = \{f(n): \exists c,n， \forall n \geq n_0,  0 \leq f(n) \leq cg(n)\}
</script>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/04/20/markup-lang/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/04/bachelor-thesis/">毕业论文点滴</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-04-04T00:00:00+08:00" pubdate data-updated="true">Apr 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>已经好久没写博客了，因为寒假一个多月都没看书，
而一回到学校，又要忙着毕业论文的事，所以也无暇顾及这个。
大部分牛人的博客，都是记载着自己正在研究的方面，
在博客中也是向读者传达着一些知识，我们总是可以从其中学到某种东西。
而我，要达到这样的程度要有很长的一段路需要走，
由于技术水平较低，现在的博客记录的仍然还是自己在<strong>学习</strong>过程中的一些心得和体会，
很大程度上是描述自己的坎坷经历，希望能给某些人一些借鉴，少走一些弯路。</p>

<p>好了，言归正传，这一个月，都在忙着做毕业设计，
包括看论文，写代码，找数据，做实验。一个月的时间，
就完成了这么一件事，效率确实不算高，
主要原因在于对于搞科研还是新手，
很多情况下都是在尝试了各种可能之后才找到方法，
有时一个人的蛮干还不如直接通过其他方式获得出路。
哎，科研就是要耐得住寂寞，不停地调参数，不停地跑数据，
把各种可能性都尝试一遍，之后才有好的结果。</p>

<p>先简单介绍一下我这个论文的要求，论文的题目叫
<code>信息缺失情况下的社区挖掘</code>，其实就是一个聚类算法，
根据节点的某些属性和节点之间的边的关系，把图中的比较接近的节点聚到一起，
形成一个社区。而信息缺失，是指节点中的某些边的关系并不知道，
在这样的情况下进行聚类。采用的办法是首先利用节点之间的属性和边的关系，
通过机器学习方法获取所有节点之间的距离，然后再根据这个距离对节点进行聚类。
下面我来说一下整个的过程。</p>

<p>首先是准备数据。一开始准备爬微博的数据，
所以就去网上搜各种微博的爬虫，
然后终于找到了这个<a href="https://bitbucket.org/chineking/weibocrawler">一个简单的分布式新浪微博爬虫</a>，
在这个基础上进行了一点小修改，弄了一个简单的单节点爬虫。
这个爬虫可以抓取用户的微博，用户的个人资料以及用户之间的关注关系。
然后，又使用<a href="http://ictclas.nlpir.org/">NLPIR</a>对微博进行分词，
提取出关键字作为用户的属性，同时以用户之间的关注关系作为边，这样就开始实验。
可是，不知道是实验室的网络不稳定还是新浪微博的限制，这个爬虫很难稳定地抓取微博的数据，
最后实在没办法，学长建议我去网上直接找别人爬取到的数据集。
于是，我先后使用了Google+, Facebook, 
Twitter(这三个数据集都是在<a href="http://snap.stanford.edu/data/">Stanford Large Network Dataset Collection</a>上找到的),
和Flixter数据集做实验。其中使用Flixter数据集做出来的结果也还可以，可是师兄说一定要有<strong>Ground Truth</strong>用于验证，
所以我又只好去找其他的数据集，
最后终于<a href="http://dmml.asu.edu/users/xufei/datasets.html">在这</a>找到了可以用于实验的数据集。</p>

<p>然后是实现代码去做实验。这个代码其实两部分，第一部分要利用机器学习去学习一个距离，
第二部分是基于距离进行聚类。为了学习距离，需要求解一个最优化函数，
而这里面涉及的数学的公式好复杂，实现起来也非常困难，
找到了一份和这个论文比较相似的论文的源代码，却发现里面错误好多，有些地方也不知道从哪里开始改。
大概修改了一下就把这个距离拿到第二步去聚类，发现结果非常差，
然后也不知道是第一步的问题还是第二步的问题，但是我就只会改第二步的代码:P。
终于在第二步实在找不出什么错误然后第一步的结果又不好之后，我去问老师，
老师让我使用谱聚类算法来验证距离是不是正确的，
因为谱聚类算法也是基于距离的聚类算法，如果谱聚类算法得不到正确的结果，那就是距离的问题了。
多好的主意啊，我当时怎么就没想到呢，因为我当时还没听说过谱聚类算法。
于是我就拿谱聚类算法去验证，果然是距离没学对，而除了代码没写对之外，
有一个重要的步骤没有做，<strong>对Feature做Normalize</strong>，
这个步骤对于使用节点的属性来说非常重要，它保证了所有属性的作用是均等的。
而后，我又在<a href="http://www.cs.cmu.edu/~liuy/distlearn.htm">这里</a>找到了一些其他的学习距离的算法，
我使用了其中的DCA算法来作为我的第一步，相当靠谱。
通过谱聚类算法验证之后，我发现我的第二步算法就几乎没有什么问题了，
跑出的结果也比较让人满意。</p>

<p>大概就是这么一个比较纠结的过程，总结出一些经验吧:</p>

<pre><code>&gt;&gt;&gt;import this
</code></pre>

<ol>
  <li>
    <p>写代码还是要多检查，一个bug除了导致几个小时的结果无效，还要浪费更多的时间去找到它。</p>
  </li>
  <li>
    <p>在一个步骤保证正确之前，不要急于开展下一步，这样只会增加更多的复杂性。</p>
  </li>
  <li>
    <p>沉下心来研究论文，尽量采用和别人一样的方法，得到的结果总是好些，虽然不知道为什么好。</p>
  </li>
  <li>
    <p>不要畏惧实验和失败，说不定下一次就是成功的那一次。</p>
  </li>
  <li>
    <p>真爱生命，远离科研。</p>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/06/clrs-24-26/">最短路径与最大流</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-06T00:00:00+08:00" pubdate data-updated="true">Jan 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">最短路径</h2>

<p>在最短路径问题中，
希望在一个图中找出从一个节点到另外一个节点的最短路径，
可能要找出从某一个特定节点到其他节点的最短路径，
也可能是找出所有节点对之间的最短路径，
图中边的权重可能为负值，甚至包含负的回路，
因此，在不同的情况下，有不同的算法适合求解问题，
关于求解所有节点之间的最短路径问题已经在动态规划时详细地解释过Floyd算法，
现在就谈谈两个处理单源最短路径的算法, Dijkstra算法和Bellman-Ford算法。</p>

<h3 id="dijkstra">Dijkstra算法</h3>

<p>Dijkstra算法用于求解所有边的权重为非负值时的单源最短路径问题，
它与Prim算法很相似，利用一个集合S保存已经求出最短路径的节点集合，
开始是S只包含源节点s,
每次从V-S中挑选出一个距离S中节点最近的节点u放入S，同时正确地设置u的邻居节点的路径长度，
直到S为V。</p>

<p>对于Dijkstra算法的正确性，只需要递归地证明下面的性质成立：</p>

<pre><code>当节点u被加入到S时，u到s的最短路径已经被正确的设置, 而且u到s的最短路径上的前趋节点w已经被添加进S。
</code></pre>

<ul>
  <li>初始化：一开始时，这个性质显然成立</li>
  <li>保持：假设当u被添加到S时，u到s的最短路径已经被正确的设置，对于u的任何一个邻接节点v，
如果s到v的最短路径是<script type="math/tex"> s \xrightarrow{p} u \xrightarrow{} v </script>，那么s到v的路径能够被正确的设置，
而且从v到s最短路径上的前趋节点u已经被添加进S, 这样当v被添加进S时，上述的性质都是能够保持的。</li>
</ul>

<h3 id="bellman-ford">Bellman-Ford算法</h3>

<p>Bellman-Ford算法用于求解权重可以为负值时的单源最短路径问题，
而且它还可以用于判断图中是否存在s可达的负的回路。
Bellman-Ford的执行过程就是运行|V|-1次更新操作，
每次更新操作遍历每一条边(u, v)更新dist[v]，伪代码如下：</p>

<div class="highlight"><pre><code class="pascal">    <span class="k">procedure</span> <span class="nf">update</span><span class="p">((</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">))</span><span class="o">:</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">,</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="mi">1</span> <span class="k">to</span> <span class="err">|</span><span class="n">V</span><span class="err">|</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">E</span><span class="o">:</span>
            <span class="n">update</span><span class="p">((</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">))</span>
</code></pre></div>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/01/06/clrs-24-26/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/31/2014-summary/">2014年终总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/15/the-mythical-man-month/">《人月神话》读书心得</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/31/2013-summary/">2013年终总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/24/bigtable/">Bigtable 学习心得</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/10/21/migrate-to-octopress/">把博客迁到Octopress</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/chouqin">@chouqin</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'chouqin',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - chouqin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'chouqinblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
